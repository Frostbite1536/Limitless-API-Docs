{
  "openapi": "3.0.0",
  "paths": {
    "/auth/signing-message": {
      "get": {
        "description": "Returns a signing message with a randomly generated nonce for authentication purposes.",
        "operationId": "AuthController_getSigningMessage",
        "parameters": [],
        "responses": {
          "200": {
            "description": "A signing message containing a nonce has been successfully generated",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "example": "Welcome to Limitless.exchange! Please sign this message to verify your identity.\n\nNonce: 0xa1b2c3d4e5f67890..."
                }
              }
            }
          }
        },
        "summary": "Get signing message",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/auth/verify-auth": {
      "get": {
        "description": "Verifies if the user is authenticated by checking the session cookie",
        "operationId": "AuthController_verifyAuth",
        "parameters": [],
        "responses": {
          "200": {
            "description": "User is authenticated",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string",
                  "description": "Ethereum address of the authenticated user",
                  "example": "0x1234567890123456789012345678901234567890"
                }
              }
            }
          },
          "401": {
            "description": "User is not authenticated",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string",
                      "example": "The token cookie is required"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "limitless_session": []
          }
        ],
        "summary": "Verify authentication",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/auth/login": {
      "post": {
        "description": "Authenticates a user with a signed message and creates a session",
        "operationId": "AuthController_login",
        "parameters": [
          {
            "name": "x-account",
            "in": "header",
            "description": "The Ethereum address of the user",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-signing-message",
            "in": "header",
            "description": "The signing message generated by the server",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "x-signature",
            "in": "header",
            "description": "The signature generated by signing the message with the user's wallet",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateUserDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "User has been successfully logged in and a session cookie has been set",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "account": {
                      "type": "string",
                      "example": "0x1234567890123456789012345678901234567890"
                    },
                    "displayName": {
                      "type": "string",
                      "example": "0x1234...7890"
                    },
                    "smartWallet": {
                      "type": "string",
                      "nullable": true,
                      "example": "0x0987654321098765432109876543210987654321"
                    },
                    "client": {
                      "type": "string",
                      "example": "eoa"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request (missing or invalid parameters)",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string",
                      "example": "Smart wallet is required"
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string",
                      "example": "Error creating JWT token"
                    }
                  }
                }
              }
            }
          }
        },
        "summary": "User login",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/auth/logout": {
      "post": {
        "description": "Logs out the user by clearing the session cookie",
        "operationId": "AuthController_logout",
        "parameters": [],
        "responses": {
          "200": {
            "description": "User has been successfully logged out",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "message": {
                      "type": "string",
                      "example": "Logged out successfully"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "limitless_session": []
          }
        ],
        "summary": "User logout",
        "tags": [
          "Authentication"
        ]
      }
    },
    "/markets/active/{categoryId}": {
      "get": {
        "description": "Retrieves markets and groups that are active and not yet resolved, with optional category filtering",
        "operationId": "MarketController_getActiveMarkets[0]",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "Page number for pagination",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "Number of items per page",
            "schema": {
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "description": "Sort by query parameter",
            "schema": {
              "example": "newest",
              "type": "string"
            }
          },
          {
            "name": "categoryId",
            "required": false,
            "in": "path",
            "description": "Filter markets by category ID",
            "schema": {
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Active markets and groups with volume and liquidity data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrowseActiveMarketsResponseDto"
                }
              }
            }
          },
          "500": {
            "description": "Server error when retrieving markets data"
          }
        },
        "summary": "Browse Active Markets",
        "tags": [
          "Markets"
        ]
      }
    },
    "/markets/active": {
      "get": {
        "description": "Retrieves markets and groups that are active and not yet resolved, with optional category filtering",
        "operationId": "MarketController_getActiveMarkets[1]",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "Page number for pagination",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "Number of items per page",
            "schema": {
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "sortBy",
            "required": false,
            "in": "query",
            "description": "Sort by query parameter",
            "schema": {
              "example": "newest",
              "type": "string"
            }
          },
          {
            "name": "categoryId",
            "required": false,
            "in": "path",
            "description": "Filter markets by category ID",
            "schema": {
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Active markets and groups with volume and liquidity data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BrowseActiveMarketsResponseDto"
                }
              }
            }
          },
          "500": {
            "description": "Server error when retrieving markets data"
          }
        },
        "summary": "Browse Active Markets",
        "tags": [
          "Markets"
        ]
      }
    },
    "/markets/categories/count": {
      "get": {
        "description": "Returns the number of active markets for each category and the total market count",
        "operationId": "MarketController_getActiveMarketCountPerCategory",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Object containing category counts and total count",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CategoryCountResponseDto"
                }
              }
            }
          },
          "500": {
            "description": "Server error when retrieving category count data"
          }
        },
        "summary": "Get active market count per category",
        "tags": [
          "Markets"
        ]
      }
    },
    "/markets/active/slugs": {
      "get": {
        "description": "Retrieves slugs, strike prices, tickers, and deadlines for all active markets and groups. Group markets are nested under their parent group.",
        "operationId": "MarketController_getActiveSlugs",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List of active market and group slugs with metadata",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "oneOf": [
                      {
                        "type": "object",
                        "properties": {
                          "slug": {
                            "type": "string",
                            "description": "Market slug identifier",
                            "example": "btc-price-prediction-2024"
                          },
                          "strikePrice": {
                            "type": "string",
                            "nullable": true,
                            "description": "Strike price extracted from market title",
                            "example": "50000"
                          },
                          "ticker": {
                            "type": "string",
                            "nullable": true,
                            "description": "Asset ticker symbol",
                            "example": "BTC"
                          },
                          "deadline": {
                            "type": "string",
                            "nullable": true,
                            "format": "date-time",
                            "description": "Market expiration deadline",
                            "example": "2024-12-31T23:59:59Z"
                          }
                        },
                        "required": [
                          "slug"
                        ],
                        "description": "Individual market entry"
                      },
                      {
                        "type": "object",
                        "properties": {
                          "slug": {
                            "type": "string",
                            "description": "Group slug identifier",
                            "example": "crypto-predictions-2024"
                          },
                          "strikePrice": {
                            "type": "null",
                            "description": "Groups do not have strike prices"
                          },
                          "ticker": {
                            "type": "string",
                            "description": "Group asset ticker symbol",
                            "example": "USDC"
                          },
                          "deadline": {
                            "type": "string",
                            "nullable": true,
                            "format": "date-time",
                            "description": "Group expiration deadline",
                            "example": "2024-12-31T23:59:59Z"
                          },
                          "markets": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "slug": {
                                  "type": "string",
                                  "description": "Market slug within the group",
                                  "example": "btc-50k-prediction"
                                }
                              },
                              "required": [
                                "slug"
                              ]
                            },
                            "description": "Array of markets within this group"
                          }
                        },
                        "required": [
                          "slug",
                          "deadline",
                          "markets"
                        ],
                        "description": "Group entry with nested markets"
                      }
                    ]
                  }
                }
              }
            }
          },
          "500": {
            "description": "Server error when retrieving market slugs"
          }
        },
        "summary": "Get active market slugs with metadata",
        "tags": [
          "Markets"
        ]
      }
    },
    "/markets/{addressOrSlug}": {
      "get": {
        "description": "Retrieves market or group data using either an Ethereum address or a slug identifier",
        "operationId": "MarketController_find",
        "parameters": [
          {
            "name": "addressOrSlug",
            "required": true,
            "in": "path",
            "description": "Market/group address (0x...) or slug identifier (my-market-name)",
            "schema": {
              "example": "crypto-predictions-2025"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Market or group details with pricing and volume data",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/ClobMarketResponseDto",
                      "description": "CLOB market with position IDs and trading data"
                    },
                    {
                      "$ref": "#/components/schemas/NegRiskGroupResponseDto",
                      "description": "NegRisk group with nested markets array"
                    },
                    {
                      "$ref": "#/components/schemas/AmmMarketResponseDto",
                      "description": "AMM market with liquidity and volume data"
                    }
                  ]
                }
              }
            }
          },
          "404": {
            "description": "Market or group not found"
          },
          "500": {
            "description": "Server error when retrieving market/group data"
          }
        },
        "summary": "Get Market Details",
        "tags": [
          "Markets"
        ]
      }
    },
    "/markets/{slug}/get-feed-events": {
      "get": {
        "description": "Retrieves the latest feed events related to a specific market with pagination support",
        "operationId": "MarketController_getFeedEvent",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "Page number for pagination",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "Number of events per page",
            "schema": {
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "slug",
            "required": false,
            "in": "path",
            "description": "Slug of the market",
            "schema": {
              "example": "my-market-slug-123"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of feed events for the market",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedEventsResponseDto"
                }
              }
            }
          },
          "500": {
            "description": "Server error when retrieving feed events"
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Get feed events for a market",
        "tags": [
          "Markets"
        ]
      }
    },
    "/markets/{slug}/historical-price": {
      "get": {
        "description": "Retrieve historical price data for a specific market with configurable time intervals",
        "operationId": "MarketOrderbookController_getHistoricalPrice",
        "parameters": [
          {
            "name": "to",
            "required": false,
            "in": "query",
            "description": "End date for historical data",
            "schema": {
              "example": "2024-01-31T23:59:59Z"
            }
          },
          {
            "name": "from",
            "required": false,
            "in": "query",
            "description": "Start date for historical data",
            "schema": {
              "example": "2024-01-01T00:00:00Z"
            }
          },
          {
            "name": "interval",
            "required": false,
            "in": "query",
            "description": "Time interval for data points",
            "schema": {
              "enum": [
                "1h",
                "6h",
                "1d",
                "1w",
                "1m",
                "all"
              ],
              "type": "string"
            }
          },
          {
            "name": "slug",
            "required": true,
            "in": "path",
            "description": "Market slug identifier",
            "schema": {
              "example": "presidential-election-2024"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Historical price data",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "title": {
                        "type": "string",
                        "example": "YES Token"
                      },
                      "prices": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "price": {
                              "type": "number",
                              "example": 0.75
                            },
                            "timestamp": {
                              "type": "string",
                              "example": "2024-01-15T10:30:00Z"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "summary": "Get Historical Prices",
        "tags": [
          "Trading"
        ]
      }
    },
    "/markets/{slug}/orderbook": {
      "get": {
        "description": "Retrieve the current orderbook for a market showing all open buy and sell orders",
        "operationId": "MarketOrderbookController_getOrderbook",
        "parameters": [
          {
            "name": "slug",
            "required": true,
            "in": "path",
            "description": "Market slug identifier",
            "schema": {
              "example": "presidential-election-2024"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Current orderbook with bids and asks",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "adjustedMidpoint": {
                      "type": "number",
                      "example": 0.75
                    },
                    "asks": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "price": {
                            "type": "number",
                            "example": 0.76
                          },
                          "size": {
                            "type": "number",
                            "example": 100
                          }
                        }
                      }
                    },
                    "bids": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "price": {
                            "type": "number",
                            "example": 0.74
                          },
                          "size": {
                            "type": "number",
                            "example": 150
                          }
                        }
                      }
                    },
                    "lastTradePrice": {
                      "type": "number",
                      "example": 0.75
                    },
                    "maxSpread": {
                      "type": "number",
                      "example": 0.05
                    },
                    "minSize": {
                      "type": "number",
                      "example": 1
                    },
                    "tokenId": {
                      "type": "string",
                      "example": "19633204485790857949828516737993423758628930235371629943999544859324645414627"
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Market does not support orderbook (AMM market)"
          },
          "404": {
            "description": "Market not found"
          }
        },
        "summary": "Get Orderbook",
        "tags": [
          "Trading"
        ]
      }
    },
    "/markets/{slug}/locked-balance": {
      "get": {
        "description": "Get the amount of funds locked in open orders for the authenticated user",
        "operationId": "MarketOrderbookController_getLockedBalance",
        "parameters": [
          {
            "name": "slug",
            "required": true,
            "in": "path",
            "description": "Market slug identifier",
            "schema": {
              "example": "presidential-election-2024"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "User's locked balance details",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "lockedBalance": {
                      "type": "string",
                      "example": "250.50"
                    },
                    "lockedBalanceFormatted": {
                      "type": "string",
                      "example": "250.50 USDC"
                    },
                    "currency": {
                      "type": "string",
                      "example": "USDC"
                    },
                    "orderCount": {
                      "type": "number",
                      "example": 3
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "limitless_session": []
          }
        ],
        "summary": "Get Locked Balance",
        "tags": [
          "Trading"
        ]
      }
    },
    "/markets/{slug}/user-orders": {
      "get": {
        "description": "Get all orders placed by the authenticated user for a specific market",
        "operationId": "MarketOrderbookController_getUserOrders",
        "parameters": [
          {
            "name": "statuses",
            "required": false,
            "in": "query",
            "description": "Order status(es) to filter by. Defaults to [LIVE] if not provided",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "LIVE",
                  "MATCHED"
                ]
              }
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "Maximum number of orders to return",
            "schema": {
              "minimum": 1,
              "example": 100,
              "type": "number"
            }
          },
          {
            "name": "slug",
            "required": true,
            "in": "path",
            "description": "Market slug identifier",
            "schema": {
              "example": "presidential-election-2024"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of user orders for the market",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "orders": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "string",
                            "example": "12345"
                          },
                          "side": {
                            "type": "string",
                            "example": "BUY"
                          },
                          "price": {
                            "type": "string",
                            "example": "0.75"
                          },
                          "quantity": {
                            "type": "string",
                            "example": "100"
                          },
                          "status": {
                            "type": "string",
                            "example": "LIVE"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "limitless_session": []
          }
        ],
        "summary": "User Orders",
        "tags": [
          "Trading"
        ]
      }
    },
    "/markets/{slug}/events": {
      "get": {
        "description": "Get recent events for a specific market including trades, orders, and liquidity changes",
        "operationId": "MarketOrderbookController_getMarketEvents",
        "parameters": [
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "Page number for pagination",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "Number of events per page",
            "schema": {
              "example": 20,
              "type": "number"
            }
          },
          {
            "name": "slug",
            "required": true,
            "in": "path",
            "description": "Market slug identifier",
            "schema": {
              "example": "presidential-election-2024"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of market events",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "events": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "string",
                            "example": "event-123"
                          },
                          "type": {
                            "type": "string",
                            "example": "ORDER_PLACED"
                          },
                          "timestamp": {
                            "type": "string",
                            "example": "2024-01-15T10:30:00Z"
                          },
                          "data": {
                            "type": "object",
                            "additionalProperties": true
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "summary": "Market Events",
        "tags": [
          "Trading"
        ]
      }
    },
    "/markets/search": {
      "get": {
        "operationId": "MarketSearchController_search",
        "parameters": [
          {
            "name": "query",
            "required": true,
            "in": "query",
            "description": "Search query text",
            "schema": {
              "example": "Sports betting markets with high odds",
              "type": "string"
            }
          },
          {
            "name": "limit",
            "required": false,
            "in": "query",
            "description": "Maximum number of results to return",
            "schema": {
              "default": 10,
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "page",
            "required": false,
            "in": "query",
            "description": "Number of page",
            "schema": {
              "default": 1,
              "example": 0,
              "type": "number"
            }
          },
          {
            "name": "similarityThreshold",
            "required": false,
            "in": "query",
            "description": "Minimum similarity score (0-1)",
            "schema": {
              "default": 0.5,
              "example": 0.5,
              "type": "number"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns markets matching the search query"
          },
          "400": {
            "description": "Invalid request parameters"
          },
          "500": {
            "description": "Internal server error"
          }
        },
        "summary": "Search for markets based on semantic similarity",
        "tags": [
          "Markets"
        ]
      }
    },
    "/portfolio/trades": {
      "get": {
        "description": "Retrieve all trades executed by the authenticated user",
        "operationId": "PortfolioController_getTrades",
        "parameters": [],
        "responses": {
          "200": {
            "description": "List of user trades with details",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "security": [
          {
            "bearer": []
          },
          {
            "limitless_session": []
          }
        ],
        "summary": "Get Trades",
        "tags": [
          "Portfolio"
        ]
      }
    },
    "/portfolio/positions": {
      "get": {
        "description": "Retrieve all active positions with P&L calculations and market values",
        "operationId": "PortfolioController_getPositions",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Complete portfolio positions with summary",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PortfolioPositionsDto"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "security": [
          {
            "bearer": []
          },
          {
            "limitless_session": []
          }
        ],
        "summary": "Get Positions",
        "tags": [
          "Portfolio"
        ]
      }
    },
    "/portfolio/history": {
      "get": {
        "description": "Paginated history including AMM, CLOB trades, splits/merges, NegRisk conversions",
        "operationId": "PortfolioController_getHistory",
        "parameters": [
          {
            "name": "page",
            "required": true,
            "in": "query",
            "description": "Page number",
            "schema": {
              "example": 1,
              "type": "number"
            }
          },
          {
            "name": "limit",
            "required": true,
            "in": "query",
            "description": "Number of items per page",
            "schema": {
              "example": 10,
              "type": "number"
            }
          },
          {
            "name": "from",
            "required": false,
            "in": "query",
            "description": "Start date for filtering (ISO 8601 format)",
            "schema": {
              "format": "date-time",
              "example": "2024-01-01T00:00:00.000Z",
              "type": "string"
            }
          },
          {
            "name": "to",
            "required": false,
            "in": "query",
            "description": "End date for filtering (ISO 8601 format)",
            "schema": {
              "format": "date-time",
              "example": "2024-12-31T23:59:59.999Z",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Paginated history of all user actions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HistoryResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Invalid pagination parameters"
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "security": [
          {
            "bearer": []
          },
          {
            "limitless_session": []
          }
        ],
        "summary": "Get History",
        "tags": [
          "Portfolio"
        ]
      }
    },
    "/portfolio/points": {
      "get": {
        "operationId": "PortfolioController_getPointsBreakdown",
        "parameters": [],
        "responses": {
          "200": {
            "description": "Points breakdown"
          },
          "401": {
            "description": "Unauthorized"
          }
        },
        "security": [
          {
            "bearer": []
          },
          {
            "limitless_session": []
          }
        ],
        "summary": "Get points breakdown",
        "tags": [
          "Portfolio"
        ]
      }
    },
    "/portfolio/{account}/traded-volume": {
      "get": {
        "description": "Get total traded volume and statistics for a specific user",
        "operationId": "PublicPortfolioController_tradedVolume",
        "parameters": [
          {
            "name": "account",
            "required": true,
            "in": "path",
            "description": "User Ethereum address",
            "schema": {
              "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "User trading volume statistics",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true
                }
              }
            }
          }
        },
        "summary": "User Total Volume",
        "tags": [
          "Public Portfolio"
        ]
      }
    },
    "/portfolio/{account}/positions": {
      "get": {
        "description": "Retrieve all positions for a specific user address",
        "operationId": "PublicPortfolioController_getPositions",
        "parameters": [
          {
            "name": "account",
            "required": true,
            "in": "path",
            "description": "User Ethereum address",
            "schema": {
              "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Complete list of user positions",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PortfolioPositionsDto"
                }
              }
            }
          }
        },
        "summary": "Get All User Positions",
        "tags": [
          "Public Portfolio"
        ]
      }
    },
    "/portfolio/trading/allowance": {
      "get": {
        "description": "Check USDC allowance for CLOB or NegRisk trading contracts",
        "operationId": "TradingPortfolioController_getAllowance",
        "parameters": [
          {
            "name": "type",
            "required": true,
            "in": "query",
            "description": "Trading type: CLOB or NegRisk",
            "schema": {
              "enum": [
                "clob",
                "negrisk"
              ],
              "type": "string"
            }
          },
          {
            "name": "spender",
            "required": false,
            "in": "query",
            "description": "Optional spender address override (e.g., venue exchange address)",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "User allowance information",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allowance": {
                      "type": "string",
                      "example": "1000000000000"
                    },
                    "hasMinimumAllowance": {
                      "type": "boolean",
                      "example": true
                    },
                    "type": {
                      "type": "string",
                      "enum": [
                        "clob",
                        "negrisk"
                      ],
                      "example": "clob"
                    },
                    "spender": {
                      "type": "string",
                      "example": "0x..."
                    },
                    "checkedAddress": {
                      "type": "string",
                      "example": "0x..."
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid type parameter"
          },
          "401": {
            "description": "Unauthorized"
          },
          "404": {
            "description": "Profile not found"
          }
        },
        "security": [
          {
            "bearer": []
          },
          {
            "limitless_session": []
          }
        ],
        "summary": "Get User Trading Allowance",
        "tags": [
          "Portfolio"
        ]
      }
    },
    "/orders": {
      "post": {
        "description": "Creates a buy/sell order for prediction market positions. Requires signed order data.",
        "operationId": "OrderController_createOrder",
        "parameters": [],
        "requestBody": {
          "required": true,
          "description": "Order creation data including signature and order parameters",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrderDto"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Order successfully created and matched",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrderResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Invalid order data, insufficient balance/allowance, or market deadline passed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseDto"
                }
              }
            }
          },
          "401": {
            "description": "User not authenticated"
          },
          "500": {
            "description": "Server error during order creation"
          }
        },
        "security": [
          {
            "limitless_session": []
          }
        ],
        "summary": "Create Order",
        "tags": [
          "Trading"
        ]
      }
    },
    "/orders/{orderId}": {
      "delete": {
        "description": "Cancel an open order and return locked funds",
        "operationId": "OrderController_cancelOrder",
        "parameters": [
          {
            "name": "orderId",
            "required": true,
            "in": "path",
            "description": "Unique identifier of the order to be cancelled",
            "schema": {
              "example": "6f52b6d2-6c9e-4a5c-8a4f-28ab4b7ff203",
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Order successfully cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelOrderResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Order cannot be cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseDto"
                }
              }
            }
          },
          "401": {
            "description": "User not authenticated or not the order owner"
          },
          "500": {
            "description": "Server error during cancellation"
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Cancel Order",
        "tags": [
          "Trading"
        ]
      }
    },
    "/orders/cancel-batch": {
      "post": {
        "operationId": "OrderController_cancelOrderBatch",
        "parameters": [],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DeleteOrderBatchDto"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "All orders successfully cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelOrderBatchResponseDto"
                }
              }
            }
          },
          "207": {
            "description": "Partial success - some orders cancelled, some failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelOrderBatchResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Orders from different markets, invalid order data, or no orders could be cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseDto"
                }
              }
            }
          },
          "401": {
            "description": "User not authenticated or not the owner of all orders",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseDto"
                }
              }
            }
          },
          "500": {
            "description": "Server error during batch cancellation"
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Cancel multiple orders in batch",
        "tags": [
          "Trading"
        ]
      }
    },
    "/orders/all/{slug}": {
      "delete": {
        "operationId": "OrderController_cancelAllOrders",
        "parameters": [],
        "responses": {
          "200": {
            "description": "All orders successfully cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelAllOrdersResponseDto"
                }
              }
            }
          },
          "207": {
            "description": "Partial success - some orders cancelled, some failed",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CancelAllOrdersResponseDto"
                }
              }
            }
          },
          "400": {
            "description": "Invalid market slug or no orders could be cancelled",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseDto"
                }
              }
            }
          },
          "401": {
            "description": "User not authenticated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponseDto"
                }
              }
            }
          },
          "500": {
            "description": "Server error during cancellation"
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Cancel all of a user's orders in a specific market",
        "tags": [
          "Trading"
        ]
      }
    }
  },
  "info": {
    "title": "Limitless Exchange API",
    "description": "\n# Limitless Exchange Trading API\n\n*Production-ready API for prediction market trading, portfolio management, and market data*\n\n> ğŸ¯ **Quick Navigation**: [Authentication](#tag/authentication) | [Markets](#tag/markets) | [Trading](#tag/trading) | [Portfolio](#tag/portfolio)\n\n---\n  \n\n\n## ğŸš€ Quick Start\n\nChoose your preferred programming language for complete end-to-end implementation:\n\n### Overview\n\nThe Limitless Exchange API offers both REST and WebSocket integration:\n\n**REST API (Trading)**:\n1. **ğŸ” Authentication**: Sign a message with your wallet to get authenticated  \n2. **ğŸ“Š Fetch Market Data**: Get market info including venue contract addresses (once per market)\n3. **ğŸ“‹ Order Creation**: Build and sign orders using EIP-712 structured data\n4. **ğŸš€ Order Submission**: Submit signed orders and receive confirmations\n\n**WebSocket API (Real-Time Data)**:\n1. **ğŸ”Œ Connection**: Connect to `/markets` namespace for real-time updates\n2. **ğŸ“Š Subscriptions**: Subscribe to market prices and position changes\n3. **ğŸ“¡ Events**: Handle live market data and transaction updates\n\n### Important: Venue System for CLOB Markets\n\nCLOB markets use a **venue system** where each market is associated with specific contract addresses. Before placing orders:\n\n1. **Fetch market data once**: `GET /markets/:slug` returns venue information\n2. **Use venue.exchange**: This is the `verifyingContract` for EIP-712 order signing\n3. **Cache the venue**: Venue data is static per market - fetch once and reuse\n\n**Sample venue response:**\n```json\n{\n  \"venue\": {\n    \"exchange\": \"0xA1b2C3...\",\n    \"adapter\": \"0xD4e5F6...\"\n  }\n}\n```\n\n### Required Approvals\n\nBefore trading, set up token approvals based on order type:\n\n| Order Type | Market Type | Approve To |\n|------------|-------------|------------|\n| BUY | All CLOB | USDC â†’ `venue.exchange` |\n| SELL | Simple CLOB | CT â†’ `venue.exchange` |\n| SELL | NegRisk/Grouped | CT â†’ `venue.exchange` AND `venue.adapter` |\n\n### Checksummed Addresses\n\nAll addresses must use **checksummed format** (EIP-55 mixed-case):\n- Authentication: `x-account` header\n- Orders: `maker` and `signer` fields\n- Example: `0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed`\n\n### Implementation Guides\n\n**[ğŸ Python Quick Start](#description/-python-quick-start)**\n- REST API: eth-account, requests, and web3.py libraries\n- WebSocket: python-socketio, asyncio integration\n\n**[â˜• Java Quick Start](#description/-java-quick-start)**  \n- REST API: Web3j, OkHttp3, and Jackson libraries\n\n**[ğŸ“¦ Node.js/TypeScript Quick Start](#description/-nodejs-typescript-quick-start)**\n- REST API: viem, ethers, and cross-fetch libraries\n- WebSocket: socket.io-client for real-time trading\n- Full TypeScript support with end-to-end examples\n\n**[ğŸ”Œ WebSocket Integration](#description/-websocket-integration)**\n- Real-time market data and position updates\n- Production-ready Python client with authentication\n\n---\n  \n\n\n## ğŸ Python Quick Start\n\nComplete end-to-end Python implementation for Limitless Exchange API integration.\n  \n\n#### Python E2E Order Creation Guide\n\nâš ï¸ **IMPORTANT DISCLAIMER** âœ¨ âš ï¸\n\n```\nThis is an example script for educational purposes only.\nLimitless Labs is not responsible for any losses or mistakes.\nThis script should be adjusted to your personal needs and risk tolerance.\nAlways test with small amounts first and understand the code before using it.\nUSE AT YOUR OWN RISK.\n```\n\nThis guide provides a complete walkthrough of creating orders on Limitless Exchange using Python, from authentication to order signing and submission.\n\n#### Overview\n\nThe order creation process involves:\n\n1. **Authentication** âœ¨: Get a signing message and authenticate with your wallet (use checksummed addresses)\n2. **Fetch Market Data** âœ¨: Get venue information from `GET /markets/:slug` (cache per market)\n3. **Order Construction** âœ¨: Build the order payload with proper parameters\n4. **EIP-712 Signing** âœ¨: Sign the order using venue's exchange address as `verifyingContract`\n5. **Order Submission** âœ¨: Submit the signed order to the API\n\n#### Important: Venue System\n\nCLOB markets use a **venue system** âœ¨ where each market has specific contract addresses. You must:\n- Fetch market data via `GET /markets/:slug` to get `venue.exchange` and `venue.adapter`\n- Use `venue.exchange` as the `verifyingContract` in EIP-712 domain\n- Cache venue data per market (it's static and doesn't change)\n\n#### Required Approvals\n\nBefore trading, set up token approvals:\n- **BUY orders** âœ¨: Approve USDC to `venue.exchange`\n- **SELL orders (simple CLOB)** âœ¨: Approve conditional tokens to `venue.exchange`\n- **SELL orders (NegRisk/grouped)** âœ¨: Approve conditional tokens to **both** âœ¨ `venue.exchange` AND `venue.adapter`\n\n#### Prerequisites\n\n#### Required Python Packages\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\npip install eth-account requests web3\n```\n\n#### Complete Implementation\n\n```python\n// ğŸ¯ Copy and customize this example\n#!/usr/bin/env python3\n\"\"\"\nLimitless Exchange Trading Script\nWARNING: This is a demo script. Use at your own risk.\nLimitless Labs is not responsible for any losses or mistakes.\n\"\"\"\n\nimport requests\nimport json\nimport time\nimport os\nfrom eth_account import Account\nfrom eth_account.messages import encode_defunct\n\n\ndef sign_message(self, message: str) -> str:\n    \"\"\"Sign a message using the private key.\"\"\"\n    if not self.account:\n        raise Exception(\"Private key not provided. Cannot sign message.\")\n\n    print(f\"ğŸ–Šï¸  Signing message for account: {self.account.address}\")\n\n    message_hash = encode_defunct(text=message)\n    signed_message = self.account.sign_message(message_hash)\n    signature_hex = signed_message.signature.hex()\n\n    print(\n        f\"   Generated signature: {signature_hex[:10]}... (length: {len(signature_hex)})\"\n    )\n\n    return signature_hex\n\n\n#### ============================================================================\n#### DISCLAIMER AND WARNING\n#### ============================================================================\nprint(\"âš ï¸  WARNING: This is an example trading script for educational purposes.\")\nprint(\"âš ï¸  Limitless Labs is not responsible for any losses or mistakes.\")\nprint(\"âš ï¸  Always test with small amounts first and understand the code.\")\nprint(\"âš ï¸  USE AT YOUR OWN RISK.\\n\")\n\n#### ============================================================================\n#### Import Compatibility Layer\n#### ============================================================================\n\ntry:\n    from eth_account.messages import encode_typed_data\n\n    print(\"âœ… Successfully imported encode_typed_data from eth_account.messages\")\nexcept ImportError:\n    try:\n        from eth_account.messages import encode_structured_data as encode_typed_data\n\n        print(\"âœ… Using encode_structured_data (fallback)\")\n    except ImportError as e:\n        print(f\"âŒ Import error: {e}\")\n\n#### ============================================================================\n#### Configuration\n#### ============================================================================\n\nAPI_BASE_URL = os.getenv(\"API_URL\", \"https://api.limitless.exchange\")\n\n#### Market cache - stores venue data per market slug (venue is static per market)\nMARKET_CACHE = {}\n\n#### EIP-712 Type Definitions\nORDER_TYPES = {\n    \"Order\": [\n        {\"name\": \"salt\", \"type\": \"uint256\"},\n        {\"name\": \"maker\", \"type\": \"address\"},\n        {\"name\": \"signer\", \"type\": \"address\"},\n        {\"name\": \"taker\", \"type\": \"address\"},\n        {\"name\": \"tokenId\", \"type\": \"uint256\"},\n        {\"name\": \"makerAmount\", \"type\": \"uint256\"},\n        {\"name\": \"takerAmount\", \"type\": \"uint256\"},\n        {\"name\": \"expiration\", \"type\": \"uint256\"},\n        {\"name\": \"nonce\", \"type\": \"uint256\"},\n        {\"name\": \"feeRateBps\", \"type\": \"uint256\"},\n        {\"name\": \"side\", \"type\": \"uint8\"},\n        {\"name\": \"signatureType\", \"type\": \"uint8\"},\n    ]\n}\n\n#### ============================================================================\n#### Utility Functions\n#### ============================================================================\n\n\ndef string_to_hex(text):\n    \"\"\"Convert string to hex representation with 0x prefix.\"\"\"\n    return \"0x\" + text.encode(\"utf-8\").hex()\n\n\n#### ============================================================================\n#### Market Data Functions\n#### ============================================================================\n\n\ndef get_market_data(slug):\n    \"\"\"\n    Fetch market data including venue information.\n    Uses cache to avoid repeated API calls (venue is static per market).\n\n    Args:\n        slug: The market slug\n\n    Returns:\n        dict: Market data including venue, tokens, etc.\n    \"\"\"\n    if slug in MARKET_CACHE:\n        print(f\"ğŸ“¦ Using cached market data for: {slug}\")\n        return MARKET_CACHE[slug]\n\n    print(f\"ğŸ“Š Fetching market data for: {slug}\")\n    response = requests.get(f\"{API_BASE_URL}/markets/{slug}\")\n    if response.status_code == 200:\n        market = response.json()\n        MARKET_CACHE[slug] = market\n        print(f\"âœ… Market data cached. Venue exchange: {market.get('venue', {}).get('exchange')}\")\n        return market\n    else:\n        raise Exception(f\"Failed to get market data: {response.status_code} - {response.text}\")\n\n\ndef get_venue_exchange(slug):\n    \"\"\"\n    Get the venue exchange address for a market (used as verifyingContract).\n\n    Args:\n        slug: The market slug\n\n    Returns:\n        str: The venue exchange address (checksummed)\n    \"\"\"\n    market = get_market_data(slug)\n    venue = market.get(\"venue\")\n    if not venue or not venue.get(\"exchange\"):\n        raise Exception(f\"Market {slug} does not have venue data\")\n    return venue[\"exchange\"]\n\n\n#### ============================================================================\n#### Authentication Functions\n#### ============================================================================\n\n\ndef get_signing_message():\n    \"\"\"\n    Fetch the signing message from the API.\n\n    Returns:\n        str: The signing message to be signed\n    \"\"\"\n    response = requests.get(f\"{API_BASE_URL}/auth/signing-message\")\n    if response.status_code == 200:\n        return response.text\n    else:\n        raise Exception(f\"Failed to get signing message: {response.status_code}\")\n\n\ndef authenticate(private_key, signing_message):\n    \"\"\"\n    Authenticate with the Limitless Exchange API.\n\n    Args:\n        private_key: Your wallet's private key\n        signing_message: The message to sign for authentication\n\n    Returns:\n        tuple: (session_cookie, user_data)\n\n    Note:\n        The address must be checksummed (EIP-55 format).\n        eth_account.Account.from_key() returns checksummed addresses by default.\n    \"\"\"\n    hex_message = \"0x\" + signing_message.encode(\"utf-8\").hex()\n\n    # Get the Ethereum address from the private key\n    if not private_key.startswith(\"0x\"):\n        private_key = \"0x\" + private_key\n    account = Account.from_key(private_key)\n    # account.address is already checksummed (EIP-55 format)\n    ethereum_address = account.address\n\n    print(f\"Using address (checksummed): {ethereum_address}\")\n    print(f\"Signing message: {repr(signing_message)}\")\n\n    # Sign the message\n    message = encode_defunct(text=signing_message)\n    signature = account.sign_message(message)\n    sig_hex = signature.signature.hex()\n    if not sig_hex.startswith(\"0x\"):\n        sig_hex = \"0x\" + sig_hex\n\n    # x-account must be checksummed address\n    headers = {\n        \"x-account\": ethereum_address,\n        \"x-signing-message\": hex_message,\n        \"x-signature\": sig_hex,\n        \"Content-Type\": \"application/json\",\n    }\n\n    response = requests.post(\n        f\"{API_BASE_URL}/auth/login\", headers=headers, json={\"client\": \"eoa\"}\n    )\n\n    if response.status_code == 200:\n        session_cookie = response.cookies.get(\"limitless_session\")\n        return session_cookie, response.json()\n    else:\n        raise Exception(\n            f\"Authentication failed: {response.status_code} - {response.text}\"\n        )\n\n\n#### ============================================================================\n#### Order Creation Functions\n#### ============================================================================\n\n\ndef create_order_payload_without_signature(\n    maker_address, token_id, maker_amount, taker_amount, fee_rate_bps\n):\n    \"\"\"\n    Create the base order payload without signature.\n\n    Args:\n        maker_address: The maker's wallet address\n        token_id: The token ID to trade (YES or NO token)\n        maker_amount: Amount the maker is offering (scaled)\n        taker_amount: Amount the maker wants in return (scaled)\n        fee_rate_bps: Fee rate in basis points\n\n    Returns:\n        dict: Order payload ready for signing\n    \"\"\"\n    salt = int(time.time() * 1000) + (24 * 60 * 60 * 1000)  # Current time + 24h in ms\n\n    return {\n        \"salt\": salt,\n        \"maker\": maker_address,\n        \"signer\": maker_address,\n        \"taker\": \"0x0000000000000000000000000000000000000000\",  # Open to any taker\n        \"tokenId\": str(token_id),  # Keep as string for API\n        \"makerAmount\": maker_amount,\n        \"takerAmount\": taker_amount,\n        \"expiration\": \"0\",  # No expiration\n        \"nonce\": 0,\n        \"feeRateBps\": fee_rate_bps,\n        \"side\": 0,  # 0 = BUY\n        \"signatureType\": 0,  # 0 = EOA signature\n    }\n\n\ndef get_eip712_domain(venue_exchange_address):\n    \"\"\"\n    Get the EIP-712 domain for signing.\n\n    Args:\n        venue_exchange_address: The venue's exchange contract address from market data\n\n    Returns:\n        dict: EIP-712 domain object\n    \"\"\"\n    return {\n        \"name\": \"Limitless CTF Exchange\",\n        \"version\": \"1\",\n        \"chainId\": 8453,  # Base chain ID\n        \"verifyingContract\": venue_exchange_address,\n    }\n\n\ndef create_signature_for_order_payload(venue_exchange_address, order_payload, private_key):\n    \"\"\"\n    Sign an order payload using EIP-712.\n\n    Args:\n        venue_exchange_address: The venue's exchange address (verifyingContract)\n        order_payload: The order data to sign\n        private_key: Private key for signing\n\n    Returns:\n        str: Hex-encoded signature\n    \"\"\"\n    # Remove '0x' prefix if present\n    if private_key.startswith(\"0x\"):\n        private_key = private_key[2:]\n\n    # Create account\n    account = Account.from_key(\"0x\" + private_key)\n\n    # Get domain data using venue's exchange address\n    domain_data = get_eip712_domain(venue_exchange_address)\n\n    # Convert string fields to int for signing\n    message_data = {\n        \"salt\": order_payload[\"salt\"],\n        \"maker\": order_payload[\"maker\"],\n        \"signer\": order_payload[\"signer\"],\n        \"taker\": order_payload[\"taker\"],\n        \"tokenId\": int(order_payload[\"tokenId\"]),\n        \"makerAmount\": order_payload[\"makerAmount\"],\n        \"takerAmount\": order_payload[\"takerAmount\"],\n        \"expiration\": int(order_payload[\"expiration\"])\n        if order_payload[\"expiration\"]\n        else 0,\n        \"nonce\": order_payload[\"nonce\"],\n        \"feeRateBps\": order_payload[\"feeRateBps\"],\n        \"side\": order_payload[\"side\"],\n        \"signatureType\": order_payload[\"signatureType\"],\n    }\n\n    print(f\"Domain: {json.dumps(domain_data, indent=2)}\")\n    print(f\"Types: {json.dumps(ORDER_TYPES, indent=2)}\")\n    print(f\"Message: {json.dumps(message_data, indent=2)}\")\n\n    # Sign using eth_account's implementation of EIP-712\n    encoded_message = encode_typed_data(domain_data, ORDER_TYPES, message_data)\n    signed_message = account.sign_message(encoded_message)\n\n    # Extract signature\n    signature = signed_message.signature.hex()\n\n    print(f\"Successfully generated EIP-712 Signature: {signature}\")\n    return \"0x\" + signature\n\n\ndef create_order_api(order_payload, session_cookie):\n    \"\"\"\n    Submit an order to the API.\n\n    Args:\n        order_payload: Complete order payload with signature\n        session_cookie: Authentication session cookie\n\n    Returns:\n        dict: API response with order details\n    \"\"\"\n    api_url = f\"{API_BASE_URL}/orders\"\n\n    headers = {\n        \"cookie\": f\"limitless_session={session_cookie}\",\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n    }\n\n    print(f\"Order payload: {json.dumps(order_payload, indent=2)}\")\n\n    try:\n        response = requests.post(\n            api_url, headers=headers, json=order_payload, timeout=35\n        )\n\n        if response.status_code != 201:\n            print(f\"Failed to create order. Status: {response.status_code}\")\n            print(f\"Response: {response.text}\")\n            raise Exception(f\"API Error {response.status_code}: {response.text}\")\n\n        result = response.json()\n        print(f\"Order created successfully: {json.dumps(result, indent=2)}\")\n        return result\n\n    except Exception as error:\n        print(f\"Error creating order: {error}\")\n        raise error\n\n\n#### ============================================================================\n#### Main Trading Function\n#### ============================================================================\n\n\ndef execute_trade(trading_params, market_slug, private_key):\n    \"\"\"\n    Main function to execute a trade on Limitless Exchange.\n\n    Args:\n        trading_params: Dictionary containing:\n            - sharePrice: price in cents (e.g., 65 for 65Â¢)\n            - amount: amount in shares (e.g., 100)\n            - firstType: \"YES\" or \"NO\"\n\n        market_slug: The market slug (used to fetch market data including venue)\n\n        private_key: Your wallet's private key\n\n    Returns:\n        dict: Order execution result\n    \"\"\"\n\n    # Step 1: Authenticate\n    signing_message = get_signing_message()\n    session_cookie, user_data = authenticate(private_key, signing_message)\n    print(f\"Authenticated as: {user_data['account']}\")\n\n    # Step 2: Fetch market data (cached per market)\n    # This gets venue info needed for EIP-712 signing\n    market_data = get_market_data(market_slug)\n    venue_exchange = market_data[\"venue\"][\"exchange\"]\n    print(f\"Using venue exchange: {venue_exchange}\")\n\n    # Step 3: Calculate amounts\n    price_in_cents = trading_params[\"sharePrice\"]\n    amount = trading_params[\"amount\"]\n    trade_type = \"GTC\"  # Good Till Cancelled\n    scaling_factor = 1000000  # 1e6 for USDC (6 decimals)\n\n    # Get token IDs from market data\n    # positionIds[0] = YES token, positionIds[1] = NO token\n    position_ids = market_data.get(\"positionIds\", [])\n    if len(position_ids) < 2:\n        raise Exception(\"Market does not have valid position IDs\")\n\n    first_user_token = (\n        position_ids[0]\n        if trading_params[\"firstType\"] == \"YES\"\n        else position_ids[1]\n    )\n\n    # Calculate amounts\n    price_in_dollars = price_in_cents / 100  # Convert cents to dollars\n    total_cost = price_in_dollars * amount  # Total cost in dollars\n    maker_amount = round(total_cost * scaling_factor)\n    taker_amount = round(amount * scaling_factor)\n\n    print(\n        f\"Trading: {amount} shares at {price_in_cents} cents ({price_in_dollars} dollars) each\"\n    )\n    print(f\"Total cost: {total_cost} dollars\")\n    print(f\"Maker amount: {maker_amount}\")\n    print(f\"Taker amount: {taker_amount}\")\n\n    # Step 4: Create order payload without signature\n    # user_data[\"account\"] is already checksummed\n    order_payload_without_signature = create_order_payload_without_signature(\n        user_data[\"account\"],\n        first_user_token,\n        maker_amount,\n        taker_amount,\n        user_data.get(\"rank\", {}).get(\"feeRateBps\", 0),\n    )\n\n    # Step 5: Sign the order using venue's exchange address\n    signature = create_signature_for_order_payload(\n        venue_exchange, order_payload_without_signature, private_key\n    )\n\n    # Step 6: Create final order payload\n    final_order_payload = {\n        \"order\": {\n            **order_payload_without_signature,\n            \"price\": price_in_dollars,  # Send as decimal\n            \"signature\": signature,\n        },\n        \"ownerId\": user_data[\"id\"],\n        \"orderType\": trade_type,\n        \"marketSlug\": market_slug,\n    }\n\n    print(\n        f\"Order placed for ${price_in_cents} cents, amount: {amount}, share type: {trading_params['firstType']}\"\n    )\n\n    # Step 7: Submit to API\n    result = create_order_api(final_order_payload, session_cookie)\n    return result\n\n\n#### ============================================================================\n#### Example Usage\n#### ============================================================================\n\nif __name__ == \"__main__\":\n    print(\"=\" * 80)\n    print(\"LIMITLESS EXCHANGE TRADING SCRIPT - DEMO\")\n    print(\"=\" * 80)\n    print(\"\\nâš ï¸  This is a demonstration script. Please modify for your needs.\")\n    print(\"âš ï¸  Never share your private key with anyone.\")\n    print(\"âš ï¸  Always test with small amounts first.\\n\")\n    print(\"=\" * 80)\n\n    # Example parameters - REPLACE THESE WITH YOUR ACTUAL VALUES\n    trading_params = {\n        \"sharePrice\": 50,  # Price in cents (50Â¢)\n        \"amount\": 2,  # Number of shares\n        \"firstType\": \"YES\",  # 'YES' or 'NO'\n    }\n\n    # Market slug - the script will fetch market data (including venue and tokens) automatically\n    market_slug = \"example-market-slug\"  # Replace with actual market slug\n\n    # SECURITY WARNING: Never hardcode your private key!\n    # Use environment variables or secure key management\n    private_key = os.getenv(\"PRIVATE_KEY\", \"<FALLBACK_VALUE_FOR_P_KEY>\")\n\n    if private_key == \"<FALLBACK_VALUE_FOR_P_KEY>\":\n        print(\n            \"âŒ ERROR: Please set your private key in the environment variable PRIVATE_KEY\"\n        )\n        print(\"Example: export PRIVATE_KEY='0x...'\")\n        exit(1)\n\n    print(\"ğŸš€ Starting trading script...\")\n    print(f\"Trading parameters: {trading_params}\")\n    print(f\"Market slug: {market_slug}\")\n\n    try:\n        # Execute the trade\n        # Market data (including venue) is fetched and cached automatically\n        result = execute_trade(trading_params, market_slug, private_key)\n        print(\"\\nâœ… Trade executed successfully!\")\n        print(f\"Result: {json.dumps(result, indent=2)}\")\n\n    except Exception as e:\n        print(f\"\\nâŒ Error executing trade: {e}\")\n        import traceback\n\n        traceback.print_exc()\n```\n\n#### Important Notes\n\n#### âš ï¸ Security Considerations\n\n- **NEVER** âœ¨ share your private key with anyone\n- **NEVER** âœ¨ commit your private key to version control\n- Use environment variables to store sensitive information\n- Always test with small amounts first\n- Understand the code before using it with real funds\n\n#### Order Types\n\n- **GTC (Good Till Cancelled)** âœ¨: Order remains active until filled or cancelled\n- **FOK (Fill or Kill)** âœ¨: Fill completely or cancel\n\n#### Price Calculation\n\n- Prices are in cents (e.g., 65 = 65Â¢ = 0.65 USD)\n- YES price = probability of outcome occurring\n- NO price = 1 - YES price\n\n#### Amount Calculation\n\n- USDC has 6 decimals (1 USDC = 1,000,000 units)\n- Shares are scaled by 1e6 for precision\n- Always verify calculations before submitting orders\n\n#### Market Types\n\n- **single-clob** âœ¨: Standard central limit order book markets\n- **group-negrisk** âœ¨: Grouped markets with multiple related outcomes\n\n#### Error Handling\n\nAlways implement proper error handling for:\n\n- Network failures\n- Authentication errors\n- Insufficient balance\n- Market closed/resolved\n- Invalid order parameters\n\n#### Environment Variables\n\nSet these environment variables for production use:\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\n#### Required\nexport PRIVATE_KEY=\"0x...\"  # Your wallet private key\n\n#### Optional (defaults shown)\nexport API_URL=\"https://api.limitless.exchange\"\n```\n\n**Note** âœ¨: Contract addresses (exchange, adapter) are now fetched dynamically from the market's venue data via `GET /markets/:slug`. You no longer need to configure them as environment variables.\n\n#### Troubleshooting\n\n#### Common Issues\n\n1. **ImportError for encode_typed_data** âœ¨\n\n   - Solution: Upgrade eth-account: `pip install eth-account==0.10.0 `\n\n2. **Authentication Failed** âœ¨\n\n   - Check that your private key is correct\n   - Ensure you're using the correct format (with or without '0x' prefix)\n\n3. **Order Creation Failed** âœ¨\n\n   - Verify market slug and token IDs are correct\n   - Check that you have sufficient balance\n   - Ensure the market is still open\n\n4. **Signature Verification Failed** âœ¨\n   - Ensure you're using the venue's exchange address from market data\n   - Verify the chain ID matches (8453 for Base)\n   - Make sure addresses are checksummed (EIP-55 format)\n\n#### Disclaimer\n\n**This script is provided for educational purposes only. Limitless Labs is not responsible for any losses, mistakes, or unintended consequences from using this code. Trading involves risk, and you should never trade more than you can afford to lose. Always understand the code you're running and test with small amounts first.** âœ¨\n\n#### Support\n\nFor API support and questions:\n\n- Documentation: https://limitlesslabs.notion.site/\n- Support: hey@limitless.network\n\n\n---\n\n\n_Last updated: 2025-12-16_\n\n\n\n## â˜• Java Quick Start\n\nComplete end-to-end Java implementation for Limitless Exchange API integration.\n  \n\n#### Java E2E Order Creation Guide\n\nâš ï¸ **IMPORTANT DISCLAIMER** âœ¨ âš ï¸\n\n```\nThis is an example implementation for educational purposes only.\nLimitless Labs is not responsible for any losses or mistakes.\nThis code should be adjusted to your personal needs and risk tolerance.\nAlways test with small amounts first and understand the code before using it.\nUSE AT YOUR OWN RISK.\n```\n\nThis guide provides a complete Java implementation for creating orders on Limitless Exchange, from authentication to order signing and submission.\n\n#### Overview\n\nThe order creation process involves:\n\n1. **Authentication** âœ¨: Get a signing message and authenticate with your wallet (use checksummed addresses)\n2. **Fetch Market Data** âœ¨: Get venue information from `GET /markets/:slug` (cache per market)\n3. **Order Construction** âœ¨: Build the order payload with proper parameters\n4. **EIP-712 Signing** âœ¨: Sign the order using venue's exchange address as `verifyingContract`\n5. **Order Submission** âœ¨: Submit the signed order to the API\n\n#### Important: Venue System\n\nCLOB markets use a **venue system** âœ¨ where each market has specific contract addresses. You must:\n\n- Fetch market data via `GET /markets/:slug` to get `venue.exchange` and `venue.adapter`\n- Use `venue.exchange` as the `verifyingContract` in EIP-712 domain\n- Cache venue data per market (it's static and doesn't change)\n\n#### Required Approvals\n\nBefore trading, set up token approvals:\n\n- **BUY orders** âœ¨: Approve USDC to `venue.exchange`\n- **SELL orders (simple CLOB)** âœ¨: Approve conditional tokens to `venue.exchange`\n- **SELL orders (NegRisk/grouped)** âœ¨: Approve conditional tokens to **both** âœ¨ `venue.exchange` AND `venue.adapter`\n\n#### Project Setup\n\n#### Project Structure\n\nCreate the following directory structure:\n\n```\nlimitless-trading-example/\nâ”œâ”€â”€ build.gradle\nâ”œâ”€â”€ gradle/\nâ”‚   â””â”€â”€ wrapper/\nâ”‚       â”œâ”€â”€ gradle-wrapper.jar\nâ”‚       â””â”€â”€ gradle-wrapper.properties\nâ”œâ”€â”€ gradlew\nâ”œâ”€â”€ gradlew.bat\nâ””â”€â”€ src/\n    â””â”€â”€ main/\n        â””â”€â”€ java/\n            â””â”€â”€ com/\n                â””â”€â”€ limitless/\n                    â””â”€â”€ example/\n                        â””â”€â”€ LimitlessTradingExample.java\n```\n\n#### Initialize Gradle Project\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\nmkdir limitless-trading-example\ncd limitless-trading-example\ngradle init --type java-application\n```\n\n#### Dependencies\n\n#### build.gradle\n\n```gradle\n// ğŸ¯ Copy and customize this example\nplugins {\n    id 'java'\n    id 'application'\n}\n\ngroup = 'com.limitless.example'\nversion = '1.0.0'\nsourceCompatibility = '11'\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    // Web3j for Ethereum operations\n    implementation 'org.web3j:core:4.9.8'\n    implementation 'org.web3j:crypto:4.9.8'\n\n    // OkHttp for HTTP operations\n    implementation 'com.squareup.okhttp3:okhttp:4.11.0'\n    implementation 'com.squareup.okhttp3:okhttp-urlconnection:4.11.0'\n\n    // Jackson for JSON processing\n    implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.2'\n\n    // Bouncy Castle for additional crypto support\n    implementation 'org.bouncycastle:bcprov-jdk15on:1.70'\n\n    // SLF4J for logging\n    implementation 'org.slf4j:slf4j-api:2.0.7'\n    implementation 'ch.qos.logback:logback-classic:1.4.8'\n\n    // Testing\n    testImplementation 'junit:junit:4.13.2'\n}\n\napplication {\n    mainClass = 'com.limitless.example.LimitlessTradingExample'\n}\n\n// Create a fat JAR with all dependencies\ntask fatJar(type: Jar) {\n    manifest {\n        attributes 'Main-Class': 'com.limitless.example.LimitlessTradingExample'\n    }\n    archiveClassifier = 'all'\n    from {\n        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }\n    }\n    with jar\n}\n```\n\n#### Complete Implementation\n\n#### LimitlessTradingExample.java\n\n```java\n// ğŸ¯ Copy and customize this example\npackage com.limitless.example;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\n\nimport okhttp3.CookieJar;\nimport okhttp3.JavaNetCookieJar;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\n\nimport org.web3j.crypto.Credentials;\nimport org.web3j.crypto.Sign;\nimport org.web3j.crypto.StructuredDataEncoder;\nimport org.web3j.crypto.Keys;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.web3j.utils.Numeric;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.net.CookieManager;\nimport java.net.HttpCookie;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Limitless Exchange Trading Example\n *\n * WARNING: This is a demo implementation. Use at your own risk.\n * Limitless Labs is not responsible for any losses or mistakes.\n *\n * This example demonstrates how to:\n * - Authenticate with the Limitless Exchange API\n * - Create and sign orders using EIP-712\n * - Submit orders to the exchange\n */\npublic class LimitlessTradingExample {\n\n    private static final Logger logger = LoggerFactory.getLogger(LimitlessTradingExample.class);\n    private static final ObjectMapper objectMapper = new ObjectMapper();\n\n    // ============================================================================\n    // Configuration\n    // ============================================================================\n\n    private static final String API_BASE_URL = System.getenv(\"API_URL\") != null ?\n        System.getenv(\"API_URL\") : \"https://api.limitless.exchange\";\n\n    private static final int CHAIN_ID = 8453; // Base chain ID\n\n    // Market cache - stores market data per slug (venue is static per market)\n    private static final Map<String, JsonNode> MARKET_CACHE = new HashMap<>();\n\n    // HTTP client with cookie support\n    private static final CookieManager cookieManager = new CookieManager();\n    private static final OkHttpClient httpClient = new OkHttpClient.Builder()\n        .cookieJar(new JavaNetCookieJar(cookieManager))\n        .connectTimeout(30, TimeUnit.SECONDS)\n        .readTimeout(30, TimeUnit.SECONDS)\n        .build();\n\n    // ============================================================================\n    // Data Classes\n    // ============================================================================\n\n    public static class TradingParams {\n        public final int firstPrice;  // Price in cents\n        public final int amount;      // Number of shares\n        public final String firstType; // \"YES\" or \"NO\"\n\n        public TradingParams(int firstPrice, int amount, String firstType) {\n            this.firstPrice = firstPrice;\n            this.amount = amount;\n            this.firstType = firstType;\n        }\n    }\n\n\n    public static class AuthResult {\n        public final String sessionCookie;\n        public final JsonNode userData;\n\n        public AuthResult(String sessionCookie, JsonNode userData) {\n            this.sessionCookie = sessionCookie;\n            this.userData = userData;\n        }\n    }\n\n    // ============================================================================\n    // Utility Functions\n    // ============================================================================\n\n    private static String stringToHex(String text) {\n        return \"0x\" + Numeric.toHexStringNoPrefix(text.getBytes(StandardCharsets.UTF_8));\n    }\n\n    // ============================================================================\n    // Market Data Functions\n    // ============================================================================\n\n    /**\n     * Fetch market data including venue information.\n     * Uses cache to avoid repeated API calls (venue is static per market).\n     */\n    private static JsonNode getMarketData(String slug) throws IOException {\n        if (MARKET_CACHE.containsKey(slug)) {\n            logger.info(\"Using cached market data for: {}\", slug);\n            return MARKET_CACHE.get(slug);\n        }\n\n        logger.info(\"Fetching market data for: {}\", slug);\n\n        Request request = new Request.Builder()\n            .url(API_BASE_URL + \"/markets/\" + slug)\n            .get()\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Failed to get market data: \" + response.code() + \" - \" + response.body().string());\n            }\n\n            JsonNode market = objectMapper.readTree(response.body().string());\n            MARKET_CACHE.put(slug, market);\n\n            String venueExchange = market.path(\"venue\").path(\"exchange\").asText(null);\n            logger.info(\"Market data cached. Venue exchange: {}\", venueExchange);\n\n            return market;\n        }\n    }\n\n    /**\n     * Get the venue exchange address for a market (used as verifyingContract).\n     */\n    private static String getVenueExchange(String slug) throws IOException {\n        JsonNode market = getMarketData(slug);\n        JsonNode venue = market.get(\"venue\");\n        if (venue == null || venue.get(\"exchange\") == null) {\n            throw new IOException(\"Market \" + slug + \" does not have venue data\");\n        }\n        return venue.get(\"exchange\").asText();\n    }\n\n    // ============================================================================\n    // Authentication\n    // ============================================================================\n\n    private static String getSigningMessage() throws IOException {\n        logger.info(\"Fetching signing message from API...\");\n\n        Request request = new Request.Builder()\n            .url(API_BASE_URL + \"/auth/signing-message\")\n            .get()\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new IOException(\"Failed to get signing message: \" + response.code());\n            }\n\n            String signingMessage = response.body().string();\n            logger.info(\"Signing message received: {}\", signingMessage);\n            return signingMessage;\n        }\n    }\n\n    private static AuthResult authenticate(String privateKey, String signingMessage) throws Exception {\n        logger.info(\"Authenticating with private key...\");\n\n        // Create credentials from private key\n        Credentials credentials = Credentials.create(privateKey);\n        String address = credentials.getAddress();\n        logger.info(\"Using address: {}\", address);\n\n        // Sign the message\n        byte[] messageBytes = signingMessage.getBytes(StandardCharsets.UTF_8);\n        Sign.SignatureData signature = Sign.signPrefixedMessage(messageBytes, credentials.getEcKeyPair());\n\n        // Convert signature to hex\n        String signatureHex = Numeric.toHexString(signature.getR()) +\n                              Numeric.toHexStringNoPrefix(signature.getS()) +\n                              Numeric.toHexStringNoPrefix(signature.getV());\n\n        // Prepare request\n        String hexMessage = stringToHex(signingMessage);\n\n        ObjectNode requestBody = objectMapper.createObjectNode();\n        requestBody.put(\"client\", \"eoa\");\n\n        RequestBody body = RequestBody.create(\n            objectMapper.writeValueAsString(requestBody),\n            MediaType.parse(\"application/json\")\n        );\n\n        String checksumAddress = Keys.toChecksumAddress(credentials.getAddress());\n\n        Request request = new Request.Builder()\n            .url(API_BASE_URL + \"/auth/login\")\n            .addHeader(\"x-account\", checksumAddress)\n            .addHeader(\"x-signing-message\", hexMessage)\n            .addHeader(\"x-signature\", signatureHex)\n            .addHeader(\"Content-Type\", \"application/json\")\n            .addHeader(\"Accept\", \"application/json\")\n            .post(body)\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            if (!response.isSuccessful()) {\n                throw new Exception(\"Authentication failed: \" + response.code() + \" - \" + response.body().string());\n            }\n\n            // Extract session cookie\n            String sessionCookie = null;\n            for (HttpCookie cookie : cookieManager.getCookieStore().getCookies()) {\n                if (\"limitless_session\".equals(cookie.getName())) {\n                    sessionCookie = cookie.getValue();\n                    break;\n                }\n            }\n\n            if (sessionCookie == null) {\n                throw new Exception(\"Session cookie not found in response\");\n            }\n\n            JsonNode userData = objectMapper.readTree(response.body().string());\n            logger.info(\"Authenticated as: {}\", userData.get(\"account\").asText());\n\n            return new AuthResult(sessionCookie, userData);\n        }\n    }\n\n    // ============================================================================\n    // Order Creation\n    // ============================================================================\n\n    private static Map<String, Object> createOrderPayloadWithoutSignature(\n            String makerAddress,\n            String tokenId,\n            long makerAmount,\n            long takerAmount,\n            int feeRateBps) {\n\n        long salt = System.currentTimeMillis() + (24L * 60 * 60 * 1000); // Current time + 24h\n\n        Map<String, Object> payload = new LinkedHashMap<>();\n        payload.put(\"salt\", salt);\n        payload.put(\"maker\", Keys.toChecksumAddress(makerAddress));\n        payload.put(\"signer\", Keys.toChecksumAddress(makerAddress));\n        payload.put(\"taker\", \"0x0000000000000000000000000000000000000000\");\n        payload.put(\"tokenId\", tokenId); // Keep as string for API\n        payload.put(\"makerAmount\", makerAmount);\n        payload.put(\"takerAmount\", takerAmount);\n        payload.put(\"expiration\", \"0\");\n        payload.put(\"nonce\", 0);\n        payload.put(\"feeRateBps\", feeRateBps);\n        payload.put(\"side\", 0); // 0 = BUY\n        payload.put(\"signatureType\", 0);\n\n        return payload;\n    }\n\n    // ============================================================================\n    // EIP-712 Signing\n    // ============================================================================\n\n    /**\n     * Get the EIP-712 domain for signing.\n     * @param venueExchangeAddress The venue's exchange contract address from market data\n     */\n    private static Map<String, Object> getEip712Domain(String venueExchangeAddress) {\n        Map<String, Object> domain = new LinkedHashMap<>();\n        domain.put(\"name\", \"Limitless CTF Exchange\");\n        domain.put(\"version\", \"1\");\n        domain.put(\"chainId\", CHAIN_ID);\n        domain.put(\"verifyingContract\", venueExchangeAddress);\n\n        return domain;\n    }\n\n    /**\n     * Sign an order payload using EIP-712.\n     * @param venueExchangeAddress The venue's exchange address (verifyingContract)\n     * @param orderPayload The order data to sign\n     * @param privateKey Private key for signing\n     */\n    private static String createSignatureForOrderPayload(\n            String venueExchangeAddress,\n            Map<String, Object> orderPayload,\n            String privateKey) throws Exception {\n\n        logger.info(\"Creating EIP-712 signature...\");\n\n        Credentials credentials = Credentials.create(privateKey);\n        Map<String, Object> domain = getEip712Domain(venueExchangeAddress);\n\n        // Convert for signing (tokenId and expiration to BigInteger)\n        Map<String, Object> signingPayload = new LinkedHashMap<>(orderPayload);\n        signingPayload.put(\"tokenId\", new BigInteger(orderPayload.get(\"tokenId\").toString()));\n        signingPayload.put(\"expiration\", new BigInteger(orderPayload.get(\"expiration\").toString()));\n\n        // Create EIP-712 typed data structure\n        ObjectNode typedData = objectMapper.createObjectNode();\n\n        // Add domain\n        ObjectNode domainNode = objectMapper.createObjectNode();\n        domainNode.put(\"name\", domain.get(\"name\").toString());\n        domainNode.put(\"version\", domain.get(\"version\").toString());\n        domainNode.put(\"chainId\", (Integer) domain.get(\"chainId\"));\n        domainNode.put(\"verifyingContract\", domain.get(\"verifyingContract\").toString());\n        typedData.set(\"domain\", domainNode);\n\n        // Add types\n        ObjectNode types = objectMapper.createObjectNode();\n\n        // EIP712Domain\n        ArrayNode domainTypeArray = objectMapper.createArrayNode();\n        domainTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"name\").put(\"type\", \"string\"));\n        domainTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"version\").put(\"type\", \"string\"));\n        domainTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"chainId\").put(\"type\", \"uint256\"));\n        domainTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"verifyingContract\").put(\"type\", \"address\"));\n        types.set(\"EIP712Domain\", domainTypeArray);\n\n        // Order\n        ArrayNode orderTypeArray = objectMapper.createArrayNode();\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"salt\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"maker\").put(\"type\", \"address\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"signer\").put(\"type\", \"address\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"taker\").put(\"type\", \"address\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"tokenId\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"makerAmount\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"takerAmount\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"expiration\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"nonce\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"feeRateBps\").put(\"type\", \"uint256\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"side\").put(\"type\", \"uint8\"));\n        orderTypeArray.add(objectMapper.createObjectNode().put(\"name\", \"signatureType\").put(\"type\", \"uint8\"));\n        types.set(\"Order\", orderTypeArray);\n\n        typedData.set(\"types\", types);\n        typedData.put(\"primaryType\", \"Order\");\n\n        // Add message\n        ObjectNode message = objectMapper.valueToTree(signingPayload);\n        typedData.set(\"message\", message);\n        typedData.put(\"primaryType\", \"Order\");\n\n        // Sign using Web3j's structured data signing\n        StructuredDataEncoder encoder = new StructuredDataEncoder(typedData.toString());\n        byte[] structuredData = encoder.getStructuredData();\n\n        Sign.SignatureData signature = Sign.signMessage(structuredData, credentials.getEcKeyPair());\n\n        String signatureHex = Numeric.toHexString(signature.getR()) +\n                             Numeric.toHexStringNoPrefix(signature.getS()) +\n                             Numeric.toHexStringNoPrefix(signature.getV());\n\n        logger.info(\"Successfully generated EIP-712 signature: {}\", signatureHex);\n        return signatureHex;\n    }\n\n    // ============================================================================\n    // Order Submission\n    // ============================================================================\n\n    private static JsonNode createOrderApi(Map<String, Object> orderPayload, String sessionCookie) throws Exception {\n        logger.info(\"Submitting order to API...\");\n\n        String jsonPayload = objectMapper.writeValueAsString(orderPayload);\n        logger.debug(\"Order payload: {}\", jsonPayload);\n\n        RequestBody body = RequestBody.create(\n            jsonPayload,\n            MediaType.parse(\"application/json\")\n        );\n\n        Request request = new Request.Builder()\n            .url(API_BASE_URL + \"/orders\")\n            .addHeader(\"Cookie\", \"limitless_session=\" + sessionCookie)\n            .addHeader(\"Content-Type\", \"application/json\")\n            .addHeader(\"Accept\", \"application/json\")\n            .post(body)\n            .build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            String responseBody = response.body().string();\n\n            if (response.code() != 201) {\n                logger.error(\"Failed to create order. Status: {}\", response.code());\n                logger.error(\"Response: {}\", responseBody);\n                throw new Exception(\"API Error \" + response.code() + \": \" + responseBody);\n            }\n\n            JsonNode result = objectMapper.readTree(responseBody);\n            logger.info(\"Order created successfully: {}\", result);\n            return result;\n        }\n    }\n\n    // ============================================================================\n    // Main Trading Function\n    // ============================================================================\n\n    /**\n     * Main function to execute a trade on Limitless Exchange.\n     * @param tradingParams Trading parameters (price, amount, type)\n     * @param marketSlug The market slug (used to fetch market data including venue)\n     * @param privateKey Your wallet's private key\n     */\n    public static JsonNode executeTrade(TradingParams tradingParams, String marketSlug, String privateKey)\n            throws Exception {\n\n        logger.info(\"=\" + \"=\".repeat(79));\n        logger.info(\"Starting trade execution...\");\n        logger.info(\"=\" + \"=\".repeat(79));\n\n        // Step 1: Authenticate\n        String signingMessage = getSigningMessage();\n        AuthResult authResult = authenticate(privateKey, signingMessage);\n\n        // Step 2: Fetch market data (cached per market)\n        // This gets venue info needed for EIP-712 signing\n        JsonNode marketData = getMarketData(marketSlug);\n        String venueExchange = marketData.path(\"venue\").path(\"exchange\").asText();\n        logger.info(\"Using venue exchange: {}\", venueExchange);\n\n        // Step 3: Calculate amounts\n        int priceInCents = tradingParams.firstPrice;\n        int amount = tradingParams.amount;\n        String tradeType = \"GTC\"; // Good Till Cancelled\n        long scalingFactor = 1000000L; // 1e6 for USDC (6 decimals)\n\n        // Get token IDs from market data\n        // positionIds[0] = YES token, positionIds[1] = NO token\n        JsonNode positionIds = marketData.get(\"positionIds\");\n        if (positionIds == null || positionIds.size() < 2) {\n            throw new Exception(\"Market does not have valid position IDs\");\n        }\n\n        String selectedToken = \"YES\".equals(tradingParams.firstType) ?\n            positionIds.get(0).asText() : positionIds.get(1).asText();\n\n        // Calculate amounts\n        double priceInDollars = priceInCents / 100.0;\n        double totalCost = priceInDollars * amount;\n        long makerAmount = Math.round(totalCost * scalingFactor);\n        long takerAmount = Math.round(amount * scalingFactor);\n\n        logger.info(\"Trading: {} shares at {} cents ({} dollars) each\",\n            amount, priceInCents, priceInDollars);\n        logger.info(\"Total cost: {} dollars\", totalCost);\n        logger.info(\"Maker amount: {}\", makerAmount);\n        logger.info(\"Taker amount: {}\", takerAmount);\n\n        // Step 4: Create order payload without signature\n        // authResult.userData.get(\"account\") is already checksummed\n        String makerAddress = authResult.userData.get(\"account\").asText();\n        int feeRateBps = authResult.userData.path(\"rank\").path(\"feeRateBps\").asInt(0);\n\n        Map<String, Object> orderPayload = createOrderPayloadWithoutSignature(\n            makerAddress,\n            selectedToken,\n            makerAmount,\n            takerAmount,\n            feeRateBps\n        );\n\n        // Step 5: Sign the order using venue's exchange address\n        String signature = createSignatureForOrderPayload(venueExchange, orderPayload, privateKey);\n\n        // Step 6: Create final order payload\n        Map<String, Object> finalOrderPayload = new LinkedHashMap<>();\n        Map<String, Object> orderWithSignature = new LinkedHashMap<>(orderPayload);\n        orderWithSignature.put(\"price\", priceInDollars);\n        orderWithSignature.put(\"signature\", signature);\n\n        finalOrderPayload.put(\"order\", orderWithSignature);\n        finalOrderPayload.put(\"ownerId\", authResult.userData.get(\"id\").asInt());\n        finalOrderPayload.put(\"orderType\", tradeType);\n        finalOrderPayload.put(\"marketSlug\", marketSlug);\n\n        logger.info(\"Order placed for {} cents, amount: {}, share type: {}\",\n            priceInCents, amount, tradingParams.firstType);\n\n        // Step 7: Submit to API\n        return createOrderApi(finalOrderPayload, authResult.sessionCookie);\n    }\n\n    // ============================================================================\n    // Main Method - Example Usage\n    // ============================================================================\n\n    public static void main(String[] args) {\n        System.out.println(\"=\" + \"=\".repeat(79));\n        System.out.println(\"LIMITLESS EXCHANGE TRADING EXAMPLE - JAVA\");\n        System.out.println(\"=\" + \"=\".repeat(79));\n        System.out.println(\"\\nâš ï¸  WARNING: This is an example trading application for educational purposes.\");\n        System.out.println(\"âš ï¸  Limitless Labs is not responsible for any losses or mistakes.\");\n        System.out.println(\"âš ï¸  Always test with small amounts first and understand the code.\");\n        System.out.println(\"âš ï¸  USE AT YOUR OWN RISK.\\n\");\n        System.out.println(\"=\" + \"=\".repeat(79));\n\n        try {\n            // Example parameters - REPLACE THESE WITH YOUR ACTUAL VALUES\n            TradingParams tradingParams = new TradingParams(\n                50,    // Price in cents (50Â¢)\n                2,     // Number of shares\n                \"YES\"  // \"YES\" or \"NO\"\n            );\n\n            // Market slug - the script will fetch market data (including venue and tokens) automatically\n            String marketSlug = \"example-market-slug\";  // Replace with actual market slug\n\n            // SECURITY WARNING: Never hardcode your private key!\n            // Use environment variables or secure key management\n            String privateKey = System.getenv(\"PRIVATE_KEY\");\n\n            if (privateKey == null || privateKey.isEmpty()) {\n                System.err.println(\"âŒ ERROR: Please set your private key in the PRIVATE_KEY environment variable\");\n                System.err.println(\"Example: export PRIVATE_KEY='0x...'\");\n                System.exit(1);\n            }\n\n            System.out.println(\"ğŸš€ Starting trading example...\");\n            System.out.println(\"Trading parameters: \" +\n                tradingParams.amount + \" shares at \" +\n                tradingParams.firstPrice + \" cents for \" +\n                tradingParams.firstType);\n            System.out.println(\"Market slug: \" + marketSlug);\n\n            // Execute the trade\n            // Market data (including venue) is fetched and cached automatically\n            JsonNode result = executeTrade(tradingParams, marketSlug, privateKey);\n\n            System.out.println(\"\\nâœ… Trade executed successfully!\");\n            System.out.println(\"Result: \" + objectMapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(result));\n\n        } catch (Exception e) {\n            System.err.println(\"\\nâŒ Error executing trade: \" + e.getMessage());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Important Notes\n\n#### âš ï¸ Security Considerations\n\n- **NEVER** âœ¨ share your private key with anyone\n- **NEVER** âœ¨ commit your private key to version control\n- Use environment variables to store sensitive information\n- Always test with small amounts first\n- Understand the code before using it with real funds\n\n#### Order Types\n\n- **GTC (Good Till Cancelled)** âœ¨: Order remains active until filled or cancelled\n- **FOK (Fill or Kill)** âœ¨: Fill completely or cancel\n\n#### Price Calculation\n\n- Prices are in cents (e.g., 65 = 65Â¢ = 0.65 USD)\n- YES price = probability of outcome occurring\n- NO price = 1 - YES price\n\n#### Amount Calculation\n\n- USDC has 6 decimals (1 USDC = 1,000,000 units)\n- Shares are scaled by 1e6 for precision\n- Always verify calculations before submitting orders\n\n#### Market Types\n\n- **single-clob** âœ¨: Standard central limit order book markets\n- **group-negrisk** âœ¨: Grouped markets with multiple related outcomes\n\n#### Build and Run\n\n#### Install Dependencies\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\n./gradlew build\n```\n\n#### Run the Application\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\n#### With environment variable\nexport PRIVATE_KEY=\"0x...\"\n./gradlew run\n\n#### Or with system property\n./gradlew run -DPRIVATE_KEY=\"0x...\"\n```\n\n#### Create Executable JAR\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\n./gradlew fatJar\njava -jar build/libs/limitless-trading-example-1.0.0-all.jar\n```\n\n#### Environment Variables\n\nSet these environment variables for production use:\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\n#### Required\nexport PRIVATE_KEY=\"0x...\"  # Your wallet private key\n\n#### Optional (defaults shown)\nexport API_URL=\"https://api.limitless.exchange\"\n```\n\n**Note** âœ¨: Contract addresses (exchange, adapter) are now fetched dynamically from the market's venue data via `GET /markets/:slug`. You no longer need to configure them as environment variables.\n\n#### Troubleshooting\n\n#### Common Issues\n\n1. **Build Failures** âœ¨\n   - Ensure Java 11+ is installed\n   - Check internet connection for dependency downloads\n   - Clear Gradle cache: `./gradlew clean`\n\n2. **Authentication Failed** âœ¨\n   - Verify private key format (with or without '0x' prefix)\n   - Check API endpoint accessibility\n   - Ensure signing message is current\n\n3. **Order Creation Failed** âœ¨\n   - Verify market slug and token IDs\n   - Check account balance\n   - Ensure market is still open\n\n4. **Signature Verification Failed** âœ¨\n   - Ensure you're using the venue's exchange address from market data\n   - Check chain ID (8453 for Base)\n   - Make sure addresses are checksummed (use `Keys.toChecksumAddress()`)\n   - Ensure Web3j version compatibility\n\n#### Key Features\n\nâœ… **Authentication** âœ¨: Message signing with Ethereum private key  \nâœ… **EIP-712 Signing** âœ¨: Complete EIP-712 typed data signing for orders  \nâœ… **Order Creation** âœ¨: Same payload structure as Python/TypeScript  \nâœ… **API Integration** âœ¨: HTTP requests with proper headers and cookies  \nâœ… **Error Handling** âœ¨: Comprehensive exception handling  \nâœ… **Logging** âœ¨: SLF4J with Logback for proper logging\n\n#### Disclaimer\n\n**This code is provided for educational purposes only. Limitless Labs is not responsible for any losses, mistakes, or unintended consequences from using this code. Trading involves risk, and you should never trade more than you can afford to lose. Always understand the code you're running and test with small amounts first.** âœ¨\n\n#### Support\n\nFor API support and questions:\n\n- Documentation: https://limitlesslabs.notion.site/\n- Support: hey@limitless.network\n\n\n---\n\n\n_Last updated: 2025-12-16_\n\n\n\n## ğŸ“¦ Node.js/TypeScript Quick Start\n\nComplete end-to-end Node.js/TypeScript implementation for trading and WebSocket subscriptions.\n  \n\n#### Node.js (TypeScript) â€“ Place Order + Subscribe to Updates\n\n```\nThis is an example for educational purposes only.\nLimitless Labs is not responsible for any losses or mistakes.\nUse at your own risk.\n```\n\n#### Overview\n\n- Place an order via REST (EIP-712 signing required)\n- Subscribe via WebSocket to:\n  - AMM price updates for specific market addresses\n  - CLOB orderbook updates for specific market slugs\n\nImportant: subscriptions replace previous ones. If you want AMM prices and CLOB orderbook at the same time, send both `marketAddresses` and `marketSlugs` together in a single `subscribe_market_prices` call.\n\nProduction WS URL: `wss://ws.limitless.exchange` namespace `/markets`\nProduction API URL: `https://api.limitless.exchange`\n\n#### Important: Venue System for CLOB Markets\n\nCLOB markets use a **venue system** âœ¨ where each market has specific contract addresses. Before placing orders:\n\n1. **Fetch market data once** âœ¨: `GET /markets/:slug` returns venue information\n2. **Use venue.exchange** âœ¨: This is the `verifyingContract` for EIP-712 order signing\n3. **Cache the venue** âœ¨: Venue data is static per market - fetch once and reuse\n\n**Required Approvals:** âœ¨\n\n- **BUY orders** âœ¨: Approve USDC to `venue.exchange`\n- **SELL orders (simple CLOB)** âœ¨: Approve conditional tokens to `venue.exchange`\n- **SELL orders (NegRisk/grouped)** âœ¨: Approve conditional tokens to **both** âœ¨ `venue.exchange` AND `venue.adapter`\n\n**Checksummed Addresses:** âœ¨\nAll addresses must use checksummed format (EIP-55). Use `getAddress()` from viem to ensure proper formatting.\n\n#### Prerequisites\n\n- Node 18+ (or any V8/Node LTS)\n- Packages:\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\npnpm add socket.io-client cross-fetch ethers viem\n```\n\n- Env variables (example):\n\n```bash\n# ğŸ’» Run in your terminal\n// ğŸ¯ Copy and customize this example\nexport PRIVATE_KEY=\"0x...\"     # Your wallet private key\nexport API_URL=\"https://api.limitless.exchange\"\n```\n\n**âš ï¸ Security Warning:** âœ¨  \nStoring private keys in `.env` files is **dangerous** âœ¨ and should only be used for development/testing purposes. For production environments, use proper secret management services.\n\n\n---\n\n\n#### TypeScript Helpers (minimal)\n\n```ts\n// ğŸ¯ Copy and customize this example\n// market.ts - Market data fetching with caching\nimport fetch from 'cross-fetch';\n\ntype MarketVenue = {\n  exchange: `0x${string}`;\n  adapter?: `0x${string}`;\n};\n\ntype MarketData = {\n  id: number;\n  slug: string;\n  positionIds: string[];\n  venue: MarketVenue;\n};\n\n// Cache market data per slug (venue is static per market)\nconst marketCache = new Map<string, MarketData>();\n\nexport async function getMarketData(apiBase: string, slug: string): Promise<MarketData> {\n  const cached = marketCache.get(slug);\n  if (cached) {\n    console.log(`Using cached market data for: ${slug}`);\n    return cached;\n  }\n\n  console.log(`Fetching market data for: ${slug}`);\n  const res = await fetch(`${apiBase}/markets/${slug}`);\n  if (!res.ok) throw new Error(`Failed to get market: ${res.status} ${await res.text()}`);\n\n  const market = (await res.json()) as MarketData;\n  marketCache.set(slug, market);\n  console.log(`Market data cached. Venue exchange: ${market.venue?.exchange}`);\n\n  return market;\n}\n\nexport function getVenueExchange(market: MarketData): `0x${string}` {\n  if (!market.venue?.exchange) {\n    throw new Error(`Market ${market.slug} does not have venue data`);\n  }\n  return market.venue.exchange;\n}\n```\n\n```ts\n// ğŸ¯ Copy and customize this example\n// auth.ts\nimport fetch from 'cross-fetch';\nimport { Wallet } from 'ethers';\n\nexport async function getSigningMessage(apiBase: string): Promise<string> {\n  const res = await fetch(`${apiBase}/auth/signing-message`);\n  if (!res.ok) throw new Error(`Failed signing-message: ${res.status}`);\n  return res.text();\n}\n\nexport async function loginWithPrivateKey(apiBase: string, privateKey: string) {\n  const wallet = new Wallet(privateKey);\n  // wallet.address is already checksummed\n  const address = await wallet.getAddress();\n\n  const message = await getSigningMessage(apiBase);\n  const signature = await wallet.signMessage(message);\n\n  // x-account must be checksummed address\n  const headers = {\n    'x-account': address,\n    'x-signing-message': `0x${Buffer.from(message, 'utf8').toString('hex')}`,\n    'x-signature': signature.startsWith('0x') ? signature : `0x${signature}`,\n    'content-type': 'application/json',\n    accept: 'application/json',\n  } as const;\n\n  const res = await fetch(`${apiBase}/auth/login`, {\n    method: 'POST',\n    headers,\n    body: JSON.stringify({ client: 'eoa' }),\n  });\n  if (!res.ok) throw new Error(`Auth failed: ${res.status} ${await res.text()}`);\n\n  const setCookie = res.headers.get('set-cookie') || '';\n  const match = /limitless_session=([^;]+)/i.exec(setCookie);\n  const session = match?.[1];\n  if (!session) throw new Error('Session cookie not found');\n\n  const user = await res.json();\n  return { session, user } as const;\n}\n```\n\n```ts\n// ğŸ¯ Copy and customize this example\n// orders.ts (viem-based FOK market order example)\nimport fetch from 'cross-fetch';\nimport { parseUnits, type WalletClient, type Account, type Transport, type Chain } from 'viem';\n\ntype OrderMessage = {\n  salt: string;\n  maker: `0x${string}`;\n  signer: `0x${string}`;\n  taker: `0x${string}`;\n  tokenId: string;\n  makerAmount: string;\n  takerAmount: string;\n  expiration: string;\n  nonce: string;\n  feeRateBps: string;\n  side: number; // 0 buy, 1 sell\n  signatureType: number; // 0 EOA\n};\n\nconst EIP712_DOMAIN = [\n  { name: 'name', type: 'string' },\n  { name: 'version', type: 'string' },\n  { name: 'chainId', type: 'uint256' },\n  { name: 'verifyingContract', type: 'address' },\n] as const;\n\nconst ORDER_STRUCTURE = [\n  { name: 'salt', type: 'uint256' },\n  { name: 'maker', type: 'address' },\n  { name: 'signer', type: 'address' },\n  { name: 'taker', type: 'address' },\n  { name: 'tokenId', type: 'uint256' },\n  { name: 'makerAmount', type: 'uint256' },\n  { name: 'takerAmount', type: 'uint256' },\n  { name: 'expiration', type: 'uint256' },\n  { name: 'nonce', type: 'uint256' },\n  { name: 'feeRateBps', type: 'uint256' },\n  { name: 'side', type: 'uint8' },\n  { name: 'signatureType', type: 'uint8' },\n] as const;\n\n/**\n * Create a signed order for CLOB trading.\n * @param client - viem WalletClient with account\n * @param options.verifyingContract - The venue's exchange address from market data (GET /markets/:slug)\n */\nexport async function createSignedOrder(\n  client: WalletClient<Transport, Chain, Account>,\n  options: {\n    amount: string; // USD amount in decimal, e.g., '1.5'\n    side: 0 | 1; // 0 buy, 1 sell\n    tokenId: string;\n    decimals?: number; // default 6\n    chainId: number; // e.g., 8453\n    verifyingContract: `0x${string}`; // venue.exchange from market data\n  },\n) {\n  const maker = client.account!.address as `0x${string}`;\n  const salt = String(Math.round(Math.random() * Date.now()));\n  const makerAmount = parseUnits(options.amount, options.decimals ?? 6).toString();\n\n  const order: OrderMessage = {\n    salt,\n    maker,\n    signer: maker,\n    taker: '0x0000000000000000000000000000000000000000',\n    tokenId: options.tokenId,\n    makerAmount,\n    takerAmount: '1', // FOK market order semantics\n    expiration: '0',\n    nonce: '0',\n    feeRateBps: '300',\n    side: options.side,\n    signatureType: 0,\n  };\n\n  const typedData = {\n    primaryType: 'Order',\n    types: { EIP712Domain: EIP712_DOMAIN, Order: ORDER_STRUCTURE },\n    domain: {\n      name: 'Limitless CTF Exchange',\n      version: '1',\n      chainId: options.chainId,\n      verifyingContract: options.verifyingContract,\n    },\n    message: order,\n  } as const;\n\n  const signature = await client.signTypedData(typedData);\n  return { order, signature } as const;\n}\n\nexport async function submitOrder(\n  apiBase: string,\n  payload: {\n    order: OrderMessage & { price?: number; signature: string };\n    ownerId: number;\n    orderType: 'FOK' | 'GTC';\n    marketSlug: string;\n  },\n  extraHeaders?: Record<string, string>,\n) {\n  const res = await fetch(`${apiBase}/orders`, {\n    method: 'POST',\n    headers: {\n      accept: 'application/json',\n      'content-type': 'application/json',\n      ...(extraHeaders || {}),\n    },\n    body: JSON.stringify(payload),\n  });\n  if (!res.ok) throw new Error(`Order failed: ${res.status} ${await res.text()}`);\n  return res.json();\n}\n```\n\n```ts\n// ğŸ¯ Copy and customize this example\n// ws.ts\nimport { io, Socket } from 'socket.io-client';\n\nexport function connectMarkets(session?: string) {\n  const url = 'wss://ws.limitless.exchange/markets';\n  const transports = ['websocket'];\n\n  const opts: Parameters<typeof io>[1] = { transports };\n  if (session) {\n    // Send cookie via extraHeaders; supported on Node\n    opts.extraHeaders = { Cookie: `limitless_session=${session}` };\n  }\n\n  const socket: Socket = io(url, opts);\n  return socket;\n}\n\n// If need to only subscribe to AMM prices, use this function\nexport function subscribeAmmPrices(socket: Socket, marketAddresses: string[]) {\n  socket.emit('subscribe_market_prices', { marketAddresses });\n\n  // Server emits 'newPriceData' to the same room\n  socket.on('newPriceData', (data: unknown) => {\n    // Shape may include: { marketAddress?, updatedPrices, blockNumber, timestamp }\n    console.log('AMM price update:', data);\n  });\n}\n\n// If need to only subscribe to CLOB orderbook, use this function\nexport function subscribeClobOrderbook(socket: Socket, marketSlugs: string[]) {\n  socket.emit('subscribe_market_prices', { marketSlugs });\n\n  // Server emits 'orderbookUpdate' per slug room\n  socket.on('orderbookUpdate', (data: unknown) => {\n    // Shape: { marketSlug, orderbook, timestamp }\n    console.log('Orderbook update:', data);\n  });\n}\n```\n\n```ts\n// ğŸ¯ Copy and customize this example\n// wallet.ts\nimport { createWalletClient, http } from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { base } from 'viem/chains';\n\nexport function createWalletFromPrivateKey(privateKey: `0x${string}`) {\n  const account = privateKeyToAccount(privateKey);\n\n  const client = createWalletClient({\n    account,\n    chain: base, // Base mainnet (chain ID 8453)\n    transport: http(),\n  });\n\n  return client;\n}\n```\n\n\n---\n\n\n#### End-to-end example\n\n```ts\n// ğŸ¯ Copy and customize this example\n// main.ts\nimport { loginWithPrivateKey } from './auth';\nimport { getMarketData, getVenueExchange } from './market';\nimport { createSignedOrder, submitOrder } from './orders';\nimport { connectMarkets } from './ws';\nimport { createWalletFromPrivateKey } from './wallet';\n\nasync function main() {\n  const API_URL = process.env.API_URL || 'https://api.limitless.exchange';\n\n  // Warning: storing private keys in .env files is dangerous, use proper secret management services.\n  const PRIVATE_KEY = process.env.PRIVATE_KEY || '';\n\n  // Market slug for CLOB trading\n  const marketSlug = 'example-market-slug'; // Replace with actual market slug\n\n  // 1) Authenticate (optional for public WS; required to place orders)\n  const { session, user } = await loginWithPrivateKey(API_URL, PRIVATE_KEY);\n  console.log('Authenticated as', user.account);\n\n  // 2) Fetch market data (cached per market) to get venue and token info\n  const market = await getMarketData(API_URL, marketSlug);\n  const verifyingContract = getVenueExchange(market);\n  console.log('Using venue exchange:', verifyingContract);\n\n  // Get token IDs from market data\n  // positionIds[0] = YES token, positionIds[1] = NO token\n  const tokenId = market.positionIds[0]; // YES token for this example\n\n  // 3) Connect WS and subscribe\n  const socket = connectMarkets(session);\n\n  // Combined subscription (send both arrays together to avoid replacing previous subscriptions)\n  const marketAddresses = ['0xE082AF5a25f5D3904fae514CD03dC99F9Ff39fBc']; // AMM markets array\n  const marketSlugs = [marketSlug]; // CLOB markets array\n  socket.emit('subscribe_market_prices', { marketAddresses, marketSlugs });\n\n  // Handlers\n  socket.on('newPriceData', (data: unknown) => console.log('AMM price update:', data)); // AMM markets only\n  socket.on('orderbookUpdate', (data: unknown) => console.log('Orderbook update:', data)); // CLOB markets only\n\n  // 4) Create wallet client from private key\n  const client = createWalletFromPrivateKey(PRIVATE_KEY as `0x${string}`);\n\n  // 5) Prepare and place CLOB order using venue's exchange address\n  const { order, signature } = await createSignedOrder(client, {\n    amount: '1.5',\n    side: 0, // 0 = BUY\n    tokenId,\n    decimals: 6,\n    chainId: 8453,\n    verifyingContract, // From venue data\n  });\n\n  const orderPayload = {\n    order: { ...order, signature },\n    ownerId: user.id,\n    orderType: 'FOK' as const,\n    marketSlug,\n  };\n\n  // 6) Submit order\n  const result = await submitOrder(API_URL, orderPayload, {\n    Cookie: `limitless_session=${session}`,\n  });\n  console.log('Order created:', result);\n}\n\nmain().catch((e) => {\n  console.error(e);\n  process.exit(1);\n});\n```\n\n\n---\n\n\n#### Event reference (server-side)\n\n- Namespace: `/markets`\n- Subscribe:\n  - `subscribe_market_prices` with `{ marketAddresses?: string[]; marketSlugs?: string[] }`\n- Emits:\n  - `newPriceData` for AMM prices\n  - `orderbookUpdate` for CLOB orderbook\n\nPayload shapes are minimal and may evolve; rely on keys shown in console in the snippets.\n\n\n---\n\n\n#### Notes\n\n- Use cookies (session) in WS headers to receive authenticated streams if/when required for certain features.\n- For public AMM prices or orderbook, authentication is not required.\n- Scale USDC to 6 decimals when computing amounts.\n- **Venue data is static** âœ¨: Fetch market data once per market and cache it. Do not fetch before every trade.\n- **Checksummed addresses** âœ¨: All addresses must be in EIP-55 checksummed format. viem's `getAddress()` and `privateKeyToAccount()` return checksummed addresses by default.\n- Contract addresses (exchange, adapter) are fetched dynamically from the market's venue data via `GET /markets/:slug`.\n\n_Last updated: 2025-12-16_\n\n\n\n## ğŸ”Œ WebSocket Integration\n\nReal-time market data and position updates using WebSocket connections.\n  \n\n##### Python WebSocket Real-Time Data Guide\n\nâš ï¸ **IMPORTANT DISCLAIMER** âš ï¸\n\n```\nThis is an example script for educational purposes only.\nLimitless Labs is not responsible for any losses or mistakes.\nThis script should be adjusted to your personal needs and risk tolerance.\nAlways test with small amounts first and understand the code before using it.\nUSE AT YOUR OWN RISK.\n```\n\nThis guide provides a complete walkthrough of connecting to Limitless Exchange WebSocket for real-time market data and position updates using Python.\n\n#### Overview\n\nThe Socket.io integration process involves:\n\n1. **Authentication**: Get a signing message and authenticate with your wallet\n2. **WebSocket Connection**: Connect to the `markets`\n3. **Event Subscription**: Subscribe to market prices and position updates\n4. **Real-Time Events**: Handle incoming market data and position changes\n\n#### Prerequisites\n\n##### Required Python Packages\n\n```bash\n# Connection Commands\npip install python-socketio[asyncio] eth-account==0.10.0 requests asyncio\n```\n\n**Important**: Make sure you have compatible versions of these packages. The script has been tested with the specified dependencies.\n\n##### Environment Variables\n\n```bash\n# Connection Commands\n##### Required for authenticated features (positions, transactions)\nexport PRIVATE_KEY=\"0x...\"  # Your wallet private key\n\n##### Optional: Enable debug logging\nexport DEBUG=1\n```\n\n#### Complete Implementation\n\n##### 1. Common Utilities (`common_utils.py`)\n\n```python\n# WebSocket Client Implementation\n#!/usr/bin/env python3\n\"\"\"\nCommon Utilities for Limitless Exchange\nShared authentication and utility functions\n\"\"\"\n\nimport requests\nfrom eth_account import Account\nfrom eth_account.messages import encode_defunct\n\n##### Import encode_structured_data with version compatibility\n\ntry:\n    from eth_account.messages import encode_typed_data\n    print(\"âœ… Successfully imported encode_typed_data from eth_account.messages\")\nexcept ImportError:\ntry:\n    from eth_account.messages import encode_structured_data as encode_typed_data\n    print(\"âœ… Using encode_structured_data (fallback)\")\nexcept ImportError as e:\n    print(f\"âŒ Import error: {e}\")\n    print(\"Please install the correct version:\")\n    print(\"pip install eth-account=0.10.0\")\nraise ImportError(\"encode_typed_data not available. Please upgrade eth-account: pip install eth-account==0.10.0\")\n\ndef string_to_hex(text):\n\"\"\"Convert string to hex representation with 0x prefix.\"\"\"\nreturn '0x' + text.encode('utf-8').hex()\n\ndef authenticate(private_key, signing_message):\n\"\"\"\nAuthenticate with Limitless Exchange API using private key\n\n    Args:\n        private_key: Private key for signing\n        signing_message: Message to sign from get_signing_message()\n\n    Returns:\n        tuple: (session_cookie, user_data)\n    \"\"\"\n    account = Account.from_key(private_key)\n    address = account.address\n    print(f\"Using address: {address}\")\n\n    print(f\"Signing message: {repr(signing_message)}\")\n    message = encode_defunct(text=signing_message)\n    signature = account.sign_message(message)\n\n    hex_message = string_to_hex(signing_message)\n    sig_hex = signature.signature.hex()\n    if not sig_hex.startswith('0x'):\n        sig_hex = '0x' + sig_hex\n\n    headers = {\n        'x-account': address,\n        'x-signing-message': hex_message,\n        'x-signature': sig_hex,\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    }\n\n    response = requests.post(\n        'https://api.limitless.exchange/auth/login',\n        headers=headers,\n        json={'client': 'eoa'}\n    )\n\n    if response.status_code == 200:\n        session_cookie = response.cookies.get('limitless_session')\n        return session_cookie, response.json()\n    else:\n        raise Exception(f\"Authentication failed: {response.status_code} - {response.text}\")\n\ndef get_signing_message():\n\"\"\"\nGet signing message from Limitless Exchange API\n\n    Returns:\n        str: Signing message to be used for authentication\n    \"\"\"\n    response = requests.get('https://api.limitless.exchange/auth/signing-message')\n    if response.status_code == 200:\n        return response.text\n    else:\n        raise Exception(f\"Failed to get signing message: {response.status_code}\")\n\n##### Re-export encode_typed_data for backward compatibility\n\n__all__ = ['authenticate', 'get_signing_message', 'string_to_hex', 'encode_typed_data']\n```\n\n##### 2. WebSocket Client (`socket-subs.py`)\n\n```\nIn below script you need to pass MARKET_ADDRESSES, please read code.\n```\n\n```python\n# WebSocket Client Implementation\n#!/usr/bin/env python3\n\"\"\"\nLimitless Exchange WebSocket Client - Streamlined Example\nPerfect for quick setup and real-time data handling\nConnect to real-time market data and position updates\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nfrom typing import Optional, List\n\nimport socketio\nfrom common_utils import authenticate, get_signing_message\n\nlogging.basicConfig(level=logging.WARNING, format='%(message)s')\nlogger = logging.getLogger(__name__)\n\n##### Global configuration\n\nMARKET_ADDRESSES = [\"<MARKET_ADDRESS>\"] # Hourly market address fetched from Active markets\n\nclass LimitlessWebSocket:\n\"\"\"\nStreamlined WebSocket client for Limitless Exchange\nEssential functionality: authentication, connection, subscription, events\n\"\"\"\n\n    def __init__(self, websocket_url: str = \"wss://ws.limitless.exchange\", private_key: Optional[str] = None):\n        self.websocket_url = websocket_url\n        self.private_key = private_key\n        self.session_cookie = None\n        self.connected = False\n        self.subscribed_markets: List[str] = []\n\n        # Socket.IO client with minimal logging\n        self.sio = socketio.AsyncClient(logger=False, engineio_logger=False)\n        self._setup_handlers()\n\n    def _setup_handlers(self):\n        \"\"\"Setup essential event handlers\"\"\"\n\n        @self.sio.event(namespace='/markets')\n        async def connect():\n            self.connected = True\n            print(\"âœ… Connected to /markets\")\n\n            # Send authentication if available\n            if self.session_cookie:\n                await self.sio.emit('authenticate', f'Bearer {self.session_cookie}', namespace='/markets')\n\n            # Re-subscribe to markets after reconnection\n            if self.subscribed_markets:\n                await asyncio.sleep(1)\n                await self._resubscribe()\n\n        @self.sio.event(namespace='/markets')\n        async def disconnect():\n            self.connected = False\n            print(\"âŒ Disconnected from /markets\")\n\n        @self.sio.event(namespace='/markets')\n        async def authenticated(data):\n            print(f\"Received packet MESSAGE data 2/markets, [\\\"authenticated\\\", {json.dumps(data)}]\")\n\n        @self.sio.event(namespace='/markets')\n        async def newPriceData(data):\n            \"\"\"Print raw newPriceData packet\"\"\"\n            print(f\"Received packet MESSAGE data 2/markets, [\\\"newPriceData\\\", {json.dumps(data)}]\")\n\n        @self.sio.event(namespace='/markets')\n        async def positions(data):\n            \"\"\"Print raw positions packet\"\"\"\n            print(f\"Received packet MESSAGE data 2/markets, [\\\"positions\\\", {json.dumps(data)}]\")\n\n        @self.sio.event(namespace='/markets')\n        async def system(data):\n            print(f\"Received packet MESSAGE data 2/markets, [\\\"system\\\", {json.dumps(data)}]\")\n\n        @self.sio.event(namespace='/markets')\n        async def exception(data):\n            \"\"\"Print raw exception packet\"\"\"\n            print(f\"Received packet MESSAGE data 2/markets, [\\\"exception\\\", {json.dumps(data)}]\")\n\n    async def authenticate(self):\n        \"\"\"Get session cookie for authentication\"\"\"\n        if not self.private_key:\n            print(\"ğŸ’¡ No private key - running in public mode\")\n            return\n\n        try:\n            print(\"ğŸ” Authenticating with private key...\")\n            signing_message = get_signing_message()\n            self.session_cookie, user_data = authenticate(self.private_key, signing_message)\n            print(f\"âœ… Authenticated as: {user_data['account']}\")\n        except Exception as e:\n            print(f\"âŒ Authentication failed: {e}\")\n\n    async def connect(self):\n        \"\"\"Connect to WebSocket with working configuration\"\"\"\n        try:\n            # Authenticate first if private key provided\n            await self.authenticate()\n\n            # Connect with same options as working version\n            print(f\"ğŸ”Œ Connecting to {self.websocket_url}...\")\n\n            # Prepare connection options with authentication headers if available\n            connect_options = {'transports': ['websocket']}\n            if self.session_cookie:\n                connect_options['headers'] = {\n                    'Cookie': f'limitless_session={self.session_cookie}'\n                }\n                print(\"ğŸª Adding session cookie to connection headers\")\n\n            await self.sio.connect(\n                self.websocket_url,\n                namespaces=['/markets'],\n                **connect_options\n            )\n\n            # Wait for connection to establish\n            max_retries = 10\n            for _ in range(max_retries):\n                if self.connected:\n                    break\n                await asyncio.sleep(0.2)\n\n            if self.connected:\n                print(\"âœ… Successfully connected\")\n            else:\n                print(\"âŒ Connection failed\")\n\n        except Exception as e:\n            print(f\"âŒ Connection error: {e}\")\n            raise\n\n    async def subscribe_markets(self, market_addresses: List[str]):\n        \"\"\"Subscribe to market price updates\"\"\"\n        if not self.connected:\n            print(\"âŒ Not connected - call connect() first\")\n            return\n\n        print(f\"ğŸ“Š Subscribing to {len(market_addresses)} markets\")\n        payload = {'marketAddresses': market_addresses}\n\n        # Subscribe to price updates\n        await self.sio.emit('subscribe_market_prices', payload, namespace='/markets')\n        print(\"âœ… Subscribed to market prices\")\n\n        # Subscribe to positions if authenticated\n        if self.session_cookie:\n            await self.sio.emit('subscribe_positions', payload, namespace='/markets')\n            print(\"âœ… Subscribed to positions\")\n\n        # Track subscribed markets for reconnection\n        self.subscribed_markets.extend(\n            addr for addr in market_addresses if addr not in self.subscribed_markets\n        )\n\n    async def _resubscribe(self):\n        \"\"\"Re-subscribe to markets after reconnection\"\"\"\n        if self.subscribed_markets:\n            await self.subscribe_markets(self.subscribed_markets)\n\n    async def disconnect(self):\n        \"\"\"Disconnect from WebSocket\"\"\"\n        if self.connected:\n            await self.sio.disconnect()\n            print(\"ğŸ‘‹ Disconnected\")\n\n    async def wait(self):\n        \"\"\"Keep connection alive and listen for events\"\"\"\n        await self.sio.wait()\n\ndef get_default_markets():\n\"\"\"Helper function to access global market addresses\"\"\"\nreturn MARKET_ADDRESSES\n\n\nasync def main():\n\"\"\"Main execution function\"\"\"\nglobal MARKET_ADDRESSES\n\n    # Check environment variable for additional markets\n\n    private_key = os.getenv('PRIVATE_KEY')\n\n    print(\"=\" * 50)\n    print(\"Limitless Exchange WebSocket Client\")\n    print(\"=\" * 50)\n\n    if private_key:\n        print(\"ğŸ” Private key detected - full market data mode\")\n    else:\n        print(\"ğŸ“Š Public mode - price data only\")\n\n    # Create and run client\n    client = LimitlessWebSocket(private_key=private_key)\n\n    try:\n        # Connect to WebSocket\n        await client.connect()\n\n        # Subscribe to markets\n        if MARKET_ADDRESSES:\n            await client.subscribe_markets(MARKET_ADDRESSES)\n        else:\n            print(\"âš ï¸ No market addresses configured\")\n            return\n\n        print(\"ğŸ“¡ Listening for events... Press Ctrl+C to stop\")\n\n        # Keep connection alive\n        await client.wait()\n\n    except KeyboardInterrupt:\n        print(\"\\nğŸ›‘ Shutting down...\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        await client.disconnect()\n\n\nasync def simple_usage_example():\n\"\"\"Simple example for API docs\"\"\" # Basic usage\nclient = LimitlessWebSocket(private_key=os.getenv('PRIVATE_KEY'))\nawait client.connect()\nawait client.subscribe_markets(MARKET_ADDRESSES)\nawait client.wait()\n\nif __name__ == \"__main__\": # Set debug logging if needed\nif os.getenv('DEBUG'):\nlogging.getLogger().setLevel(logging.DEBUG)\n\n    asyncio.run(main())\n```\n\n#### Key Features\n\n##### ğŸ” Authentication Modes\n\nThe WebSocket client supports two modes:\n\n- **Public Mode**: Access to market prices without authentication\n- **Authenticated Mode**: Full access including position updates and transactions\n\n##### ğŸ“¡ Event Types\n\n\n- **`newPriceData`**: Real-time price updates for markets - Public\n- **`positions`**: User position changes - Required\n- **`system`**: Connection status and notifications - Public\n- **`authenticated`**: Authentication confirmation - Required\n- **`exception`**: Error messages and exceptions - Public\n\n\n\n##### ğŸ¯ Market Subscription\n\n```python\n# WebSocket Client Implementation\n##### Subscribe to specific markets\nawait client.subscribe_markets([\n    \"0x1234...\",  # Market address 1\n    \"0x5678...\"   # Market address 2\n])\n```\n\n#### Usage Examples\n\n##### Basic Connection (Public Data)\n\n```python\n# WebSocket Client Implementation\nimport asyncio\nfrom socket_subs import LimitlessWebSocket\n\nasync def public_data_example():\n    client = LimitlessWebSocket()\n    await client.connect()\n    await client.subscribe_markets([\"0x1234...\"])\n    await client.wait()\n\nasyncio.run(public_data_example())\n```\n\n##### Authenticated Connection (Full Data)\n\n```python\n# WebSocket Client Implementation\nimport os\nimport asyncio\nfrom socket_subs import LimitlessWebSocket\n\nasync def authenticated_example():\n    private_key = os.getenv('PRIVATE_KEY') ##please define on shell level export PRIVATE_KEY='0x...'\n    client = LimitlessWebSocket(private_key=private_key)\n\n    await client.connect()\n    await client.subscribe_markets([\"0x1234...\"]) # on script level is passed automatically\n    await client.wait()\n\nasyncio.run(authenticated_example())\n```\n\n##### Custom Event Handling\n\n```python\n# WebSocket Client Implementation\nclass CustomWebSocket(LimitlessWebSocket):\n    def _setup_handlers(self):\n        super()._setup_handlers()\n\n        @self.sio.event(namespace='/markets')\n        async def newPriceData(data):\n            \"\"\"Custom price data handler\"\"\"\n            market_address = data.get('marketAddress')\n            prices = data.get('updatedPrices', {})\n            print(f\"Market {market_address}: YES={prices.get('yes')}, NO={prices.get('no')}\")\n\n        @self.sio.event(namespace='/markets')\n        async def positions(data):\n            \"\"\"Custom position handler\"\"\"\n            account = data.get('account')\n            positions = data.get('positions', [])\n            print(f\"User {account} has {len(positions)} positions\")\n```\n\n#### Important Notes\n\n##### âš ï¸ Security Considerations\n\n- **NEVER** share your private key with anyone\n- **NEVER** commit your private key to version control\n- Use environment variables to store sensitive information\n- Test with small amounts first\n- Understand the code before using it with real funds\n\n##### WebSocket Configuration\n\n- **URL**: `wss://ws.limitless.exchange` (production)\n- **Namespace**: `/markets` for trading data\n- **Transport**: WebSocket only (no polling fallback)\n- **Authentication**: JWT session cookies\n\n##### Connection Management\n\n- **Auto-reconnection**: Built-in reconnection logic\n- **Market re-subscription**: Automatic re-subscription after reconnection\n- **Error handling**: Comprehensive error logging and recovery\n\n##### Market Address Format\n\nMarket addresses are contract addresses in hexadecimal format, example:\n\n```\n0x1234567890123456789012345678901234567890\n```\n\nGet active market addresses from:\n\n- API endpoint: `/markets`\n- WebSocket events\n- Market browser\n\n#### Event Data Schemas\n\n##### Price Update Event\n\n```json\n{\n  \"marketAddress\": \"0x1234...\",\n  \"updatedPrices\": {\n    \"yes\": \"0.65\",\n    \"no\": \"0.35\"\n  },\n  \"blockNumber\": 12345678,\n  \"timestamp\": \"2024-01-01T00:00:00.000Z\"\n}\n```\n\n##### Position Update Event\n\n```json\n{\n  \"account\": \"0xabcd...\",\n  \"marketAddress\": \"0x1234...\",\n  \"positions\": [\n    {\n      \"tokenId\": \"123456\",\n      \"balance\": \"1000000\",\n      \"outcomeIndex\": 0\n    }\n  ],\n  \"type\": \"AMM\"\n}\n```\n\n##### System Message Event\n\n```json\n{\n  \"message\": \"Successfully subscribed to market price updates\",\n  \"markets\": [\"0x1234...\", \"0x5678...\"]\n}\n```\n\n#### Troubleshooting\n\n##### Common Issues\n\n1. **Import Error for socketio**\n\n   - Solution: Install with async support: `pip install python-socketio[asyncio]`\n\n2. **Connection Failed**\n\n   - Check WebSocket URL is correct\n   - Verify network connectivity\n   - Check if market addresses are valid\n\n3. **Authentication Failed**\n\n   - Verify private key format (with or without '0x' prefix)\n   - Check that signing message request succeeds\n   - Ensure wallet has sufficient permissions\n\n4. **No Data Received**\n   - Verify market addresses are active\n   - Check subscription was successful\n   - Enable debug logging to see raw events\n\n##### Debug Mode\n\nEnable detailed logging:\n\n```bash\n# Connection Commands\nexport DEBUG=1\npython socket-subs.py\n```\n\n#### Environment Variables\n\nSet these environment variables for production use:\n\n```bash\n# Connection Commands\n##### Required for authenticated features\nexport PRIVATE_KEY=\"0x...\"  # Your wallet private key\n\n##### Optional debugging\nexport DEBUG=1  # Enable debug logging\n```\n\n#### WebSocket Events Reference\n\n\n- **`connect`**: Server â†’ Client - None - Connection established\n- **`disconnect`**: Server â†’ Client - None - Connection lost\n- **`subscribe_market_prices`**: Client â†’ Server - None - Subscribe to price updates\n- **`subscribe_positions`**: Client â†’ Server - Required - Subscribe to position updates\n- **`newPriceData`**: Server â†’ Client - None - Market price update\n- **`positions`**: Server â†’ Client - Required - Position balance update\n- **`system`**: Server â†’ Client - None - System notifications\n- **`authenticated`**: Server â†’ Client - Required - Authentication confirmation\n- **`exception`**: Server â†’ Client - None - Error notifications\n\n\n\n#### Performance Considerations\n\n- **Connection pooling**: Reuse connections when possible\n- **Event batching**: Handle multiple events efficiently\n- **Memory usage**: Monitor memory consumption for long-running processes\n- **Reconnection limits**: Implement exponential backoff for failed connections\n\n#### Disclaimer\n\n**This script is provided for educational purposes only. Limitless Labs is not responsible for any losses, mistakes, or unintended consequences from using this code. Trading involves risk, and you should never trade more than you can afford to lose. Always understand the code you're running and test with small amounts first.**\n\n#### Support\n\nFor API support and questions:\n\n- Documentation: https://limitlesslabs.notion.site/\n- Support: hey@limitless.network\n\n\n---\n\n\n_Last updated: 2025-09-05_\n",
    "version": "1.0",
    "contact": {
      "name": "API Support",
      "url": "https://limitless.exchange",
      "email": "hey@limitless.network"
    }
  },
  "tags": [
    {
      "name": "Authentication",
      "description": "User authentication and session management"
    },
    {
      "name": "Markets",
      "description": "Browse, search, and analyze prediction markets"
    },
    {
      "name": "Trading",
      "description": "Create, manage, and cancel orders"
    },
    {
      "name": "Portfolio",
      "description": "Position tracking, trade history, and performance"
    }
  ],
  "servers": [
    {
      "url": "https://api.limitless.exchange",
      "description": "Production API"
    }
  ],
  "components": {
    "securitySchemes": {
      "apiKey": {
        "type": "apiKey",
        "in": "header",
        "name": "X-API-Key",
        "description": "API key for programmatic access. Generate at limitless.exchange (profile â†’ Api keys). Keys start with 'lmts_'."
      },
      "cookie": {
        "type": "apiKey",
        "in": "cookie",
        "name": "limitless_session",
        "description": "DEPRECATED: Session authentication cookie obtained from /auth/login. Will be removed within weeks. Migrate to API key (X-API-Key header)."
      },
      "bearer": {
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "JWT token for API access (alternative to cookie auth)",
        "name": "Authorization",
        "type": "http",
        "in": "Header"
      }
    },
    "schemas": {
      "CreateUserDto": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "description": "Client type for authentication",
            "enum": [
              "eoa",
              "etherspot",
              "base"
            ],
            "example": "eoa"
          },
          "smartWallet": {
            "type": "string",
            "description": "Smart wallet address (required for Smart Wallet client)",
            "example": "0x1234567890123456789012345678901234567890"
          },
          "r": {
            "type": "string",
            "description": "Referral code associated with the user who referred (invited) this user"
          }
        },
        "required": [
          "client"
        ]
      },
      "BrowseActiveMarketsResponseDto": {
        "type": "object",
        "properties": {
          "data": {
            "type": "array",
            "description": "Array of active markets with complete trading data including volume, liquidity, and recent feed events",
            "example": [
              {
                "id": 7495,
                "address": "0x76d3e2098Be66Aa7E15138F467390f0Eb7349B9b",
                "conditionId": "0x812f578437dc536def1412e4e593ef310884262c22868b30c1e58582e5f3e9bf",
                "title": "$DOGE above $0.21652 on Sep 1, 12:00 UTC?",
                "description": "This market will resolve to \"YES\" if the price of $DOGE is above $0.21652...",
                "collateralToken": {
                  "address": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
                  "decimals": 6,
                  "symbol": "USDC"
                },
                "creator": {
                  "name": "Limitless",
                  "imageURI": "https://limitless.exchange/assets/images/logo.svg",
                  "link": "https://x.com/trylimitless"
                },
                "prices": [
                  42.8,
                  57.2
                ],
                "categories": [
                  "Hourly"
                ],
                "tags": [
                  "Lumy",
                  "Recurring",
                  "Hourly",
                  "Simple Mode"
                ],
                "status": "FUNDED",
                "expired": false,
                "expirationDate": "Sep 1, 2025",
                "expirationTimestamp": 1756728000000,
                "volume": "164109293",
                "volumeFormatted": "164.109293",
                "openInterest": "48310707",
                "openInterestFormatted": "48.310707",
                "liquidity": "50000000",
                "liquidityFormatted": "50.000000",
                "tradeType": "amm",
                "marketType": "single",
                "slug": "dollardoge-above-dollar021652-on-sep-1-1200-utc-1756724413009",
                "feedEvents": [
                  {
                    "eventType": "NEW_TRADE",
                    "timestamp": "2025-09-01T11:30:31.000Z",
                    "user": {
                      "id": 7080,
                      "account": "0xea27f6788F083e6070961d3E52A2e596367E04CC",
                      "name": "GG",
                      "rankName": "Bronze",
                      "points": "0.00000000"
                    },
                    "data": {
                      "title": "$DOGE above $0.21652 on Sep 1, 12:00 UTC?",
                      "address": "0x76d3e2098Be66Aa7E15138F467390f0Eb7349B9b",
                      "strategy": "Buy",
                      "outcome": "NO",
                      "contracts": "9.071313",
                      "tradeAmount": "5",
                      "tradeAmountUSD": "4.999525",
                      "marketId": 7495
                    }
                  }
                ]
              }
            ],
            "items": {
              "type": "object",
              "description": "Market object with complete trading data (FEMarket type)",
              "additionalProperties": true
            }
          },
          "totalMarketsCount": {
            "type": "number",
            "description": "Total number of active markets available for pagination",
            "example": 150
          }
        },
        "required": [
          "data",
          "totalMarketsCount"
        ]
      },
      "CategoryCountResponseDto": {
        "type": "object",
        "properties": {
          "category": {
            "type": "object",
            "description": "Number of active markets per category",
            "example": {
              "1": 10,
              "2": 5,
              "3": 8
            },
            "additionalProperties": {
              "type": "number"
            }
          },
          "totalCount": {
            "type": "number",
            "description": "Total number of active markets",
            "example": 23
          }
        },
        "required": [
          "category",
          "totalCount"
        ]
      },
      "FeedEventsResponseDto": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "description": "Array of feed events with pagination (FEFeedEvents type)",
            "example": {
              "data": [
                {
                  "eventType": "NEW_TRADE",
                  "timestamp": "2025-09-01T11:30:31.000Z",
                  "user": {
                    "name": "GG",
                    "rankName": "Bronze"
                  },
                  "data": {
                    "title": "Market Title",
                    "strategy": "Buy",
                    "outcome": "YES"
                  }
                }
              ],
              "totalPages": 5
            },
            "additionalProperties": true
          }
        },
        "required": [
          "data"
        ]
      },
      "PortfolioRewardsChartEntryDto": {
        "type": "object",
        "properties": {
          "timestamp": {
            "type": "number",
            "description": "Timestamp of the rewards entry",
            "example": 1672531200000
          },
          "userRewards": {
            "type": "string",
            "description": "User rewards for this timestamp in token decimals",
            "example": "25000000"
          },
          "totalRewards": {
            "type": "string",
            "description": "Total rewards for this timestamp in token decimals",
            "example": "60000000"
          }
        },
        "required": [
          "timestamp",
          "userRewards",
          "totalRewards"
        ]
      },
      "EpochRewardDataDto": {
        "type": "object",
        "properties": {
          "epochId": {
            "type": "number",
            "description": "Unique identifier of the epoch",
            "example": 1
          },
          "timestamp": {
            "format": "date-time",
            "type": "string",
            "description": "Timestamp when the epoch occurred",
            "example": "2024-01-01T00:00:00.000Z"
          },
          "totalRewards": {
            "type": "string",
            "description": "Total rewards distributed in this epoch in token decimals",
            "example": "1500000"
          },
          "userRewards": {
            "type": "string",
            "description": "User rewards earned in this epoch in token decimals",
            "example": "150000"
          },
          "earnedPercent": {
            "type": "number",
            "description": "Part of total rewards earned by the user - [0; 1]",
            "example": 0.1
          }
        },
        "required": [
          "epochId",
          "timestamp",
          "totalRewards",
          "userRewards",
          "earnedPercent"
        ]
      },
      "PortfolioRewardsDto": {
        "type": "object",
        "properties": {
          "todaysRewards": {
            "type": "string",
            "description": "Rewards earned today in token decimals",
            "example": "50250000"
          },
          "totalUnpaidRewards": {
            "type": "string",
            "description": "Total unpaid rewards in token decimals",
            "example": "200750000"
          },
          "totalUserRewardsLastEpoch": {
            "type": "string",
            "description": "Total user rewards from the last epoch in token decimals",
            "example": "150500000"
          },
          "rewardsChartData": {
            "description": "Chart data showing rewards over time",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PortfolioRewardsChartEntryDto"
            }
          },
          "rewardsByEpoch": {
            "description": "Rewards data by epoch",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/EpochRewardDataDto"
            }
          }
        },
        "required": [
          "todaysRewards",
          "totalUnpaidRewards",
          "totalUserRewardsLastEpoch",
          "rewardsByEpoch"
        ]
      },
      "AmmPositionDto": {
        "type": "object",
        "properties": {
          "collateralAmount": {
            "type": "string",
            "description": "Amount of collateral invested in token decimals",
            "example": "100500000"
          },
          "latestTrade": {
            "type": "object",
            "description": "Latest trade associated with this position"
          },
          "market": {
            "type": "object",
            "description": "Market information for this position"
          },
          "outcomeIndex": {
            "type": "number",
            "description": "Index of the outcome token",
            "example": 0
          },
          "outcomeTokenAmount": {
            "type": "string",
            "description": "Amount of outcome tokens held in token decimals",
            "example": "50250000"
          },
          "account": {
            "type": "string",
            "description": "Wallet address that was used to create this position",
            "example": "0x1234567890123456789012345678901234567890"
          }
        },
        "required": [
          "market",
          "outcomeIndex"
        ]
      },
      "Market": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "The address of the FixedProductMarketMaker contract.",
            "minLength": 42,
            "maxLength": 42,
            "nullable": true,
            "uniqueItems": true
          },
          "title": {
            "type": "string",
            "description": "Represents the question of the market, the title metadata of the market.",
            "maxLength": 70,
            "nullable": false,
            "uniqueItems": true
          },
          "proxyTitle": {
            "type": "string",
            "maxLength": 70,
            "default": null,
            "nullable": true,
            "uniqueItems": true
          },
          "description": {
            "type": "string",
            "description": "The description of the market.",
            "uniqueItems": false,
            "nullable": false
          },
          "question_id": {
            "type": "object",
            "description": "The bytes32 parsed title of the market.",
            "minLength": 66,
            "maxLength": 66,
            "uniqueItems": true,
            "nullable": true
          },
          "condition_id": {
            "type": "object",
            "description": "The bytes32 conditionId of the market, representing the conditions defined on condition preparation.",
            "minLength": 66,
            "maxLength": 66,
            "nullable": true,
            "uniqueItems": true
          },
          "position_ids": {
            "description": "Array of position IDs (max 2 elements)",
            "maxItems": 2,
            "nullable": true,
            "items": {
              "type": "array"
            },
            "type": "array"
          },
          "outcome_slot_count": {
            "type": "number",
            "description": "The number of outcomes in the market.",
            "minimum": 2,
            "maximum": 2,
            "nullable": false,
            "default": 2
          },
          "winning_index": {
            "type": "number",
            "description": "The outcome index that was reported by the oracle.",
            "minimum": 0,
            "maximum": 1,
            "nullable": true
          },
          "payout_numerators": {
            "description": "The oracle payout numerators that the oracle reported.",
            "nullable": true,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "status": {
            "type": "string",
            "description": "Indicates the status of the market.",
            "nullable": false
          },
          "og_url": {
            "type": "string",
            "description": "The URL of the market OG image for SEO.",
            "nullable": true
          },
          "image_url": {
            "type": "string",
            "description": "The URL of the market logo image for SEO.",
            "nullable": true
          },
          "deadline": {
            "type": "string",
            "description": "The deadline of the market.",
            "nullable": false
          },
          "hidden": {
            "type": "boolean",
            "default": false
          },
          "txHash": {
            "type": "string",
            "default": null
          },
          "resolutionTxHash": {
            "type": "string",
            "default": null
          },
          "priority_index": {
            "type": "number",
            "default": null
          }
        },
        "required": [
          "address",
          "title",
          "proxyTitle",
          "description",
          "question_id",
          "condition_id",
          "position_ids",
          "outcome_slot_count",
          "winning_index",
          "payout_numerators",
          "status",
          "og_url",
          "image_url",
          "deadline",
          "hidden",
          "txHash",
          "resolutionTxHash",
          "priority_index"
        ]
      },
      "PositionDataDto": {
        "type": "object",
        "properties": {
          "cost": {
            "type": "string",
            "description": "Cost basis of the position in token decimals (e.g. 1 USDC = 1000000)",
            "example": "75000000"
          },
          "fillPrice": {
            "type": "string",
            "description": "Average fill price of the position (price per share in token decimals)",
            "example": "750000"
          },
          "realisedPnl": {
            "type": "string",
            "description": "Realized profit/loss from closed positions in token decimals",
            "example": "0"
          },
          "unrealizedPnl": {
            "type": "string",
            "description": "Unrealized profit/loss based on current market price in token decimals",
            "example": "25000000"
          },
          "marketValue": {
            "type": "string",
            "description": "Current market value of the position in token decimals",
            "example": "100000000"
          }
        },
        "required": [
          "cost",
          "fillPrice",
          "realisedPnl",
          "unrealizedPnl",
          "marketValue"
        ]
      },
      "MarketPositionDataDto": {
        "type": "object",
        "properties": {
          "yes": {
            "description": "Position data for YES outcome",
            "example": {
              "cost": "75000000",
              "fillPrice": "750000",
              "realisedPnl": "0",
              "unrealizedPnl": "25000000",
              "marketValue": "100000000"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PositionDataDto"
              }
            ]
          },
          "no": {
            "description": "Position data for NO outcome",
            "example": {
              "cost": "25000000",
              "fillPrice": "250000",
              "realisedPnl": "0",
              "unrealizedPnl": "-5000000",
              "marketValue": "20000000"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PositionDataDto"
              }
            ]
          }
        },
        "required": [
          "yes",
          "no"
        ]
      },
      "ClobPositionDto": {
        "type": "object",
        "properties": {
          "market": {
            "description": "Market information",
            "allOf": [
              {
                "$ref": "#/components/schemas/Market"
              }
            ]
          },
          "positions": {
            "description": "Position data for the market",
            "allOf": [
              {
                "$ref": "#/components/schemas/MarketPositionDataDto"
              }
            ]
          },
          "latestTrade": {
            "type": "object",
            "description": "Latest trade prices"
          },
          "tokensBalance": {
            "type": "object",
            "description": "Token balances in token decimals"
          },
          "orders": {
            "type": "object",
            "description": "Order information"
          },
          "rewards": {
            "type": "object",
            "description": "Rewards information for this position"
          }
        },
        "required": [
          "market",
          "positions",
          "tokensBalance",
          "orders"
        ]
      },
      "PortfolioPositionsDto": {
        "type": "object",
        "properties": {
          "rewards": {
            "description": "Rewards information for the portfolio",
            "allOf": [
              {
                "$ref": "#/components/schemas/PortfolioRewardsDto"
              }
            ]
          },
          "amm": {
            "description": "List of AMM positions",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AmmPositionDto"
            }
          },
          "clob": {
            "description": "List of CLOB positions",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ClobPositionDto"
            }
          }
        },
        "required": [
          "rewards",
          "amm",
          "clob"
        ]
      },
      "HistoryMarketGroupDto": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number",
            "description": "Unique identifier of the group",
            "example": 10000037
          },
          "slug": {
            "type": "string",
            "description": "Slug identifier of the group",
            "example": "positionconverted-test-1744046422596"
          },
          "title": {
            "type": "string",
            "description": "Title of the group",
            "example": "PositionConverted test"
          },
          "status": {
            "type": "string",
            "description": "Status of the group",
            "example": "FUNDED"
          },
          "deadline": {
            "type": "string",
            "description": "Deadline for the group",
            "example": "2025-04-11T22:34:56.000Z"
          },
          "hidden": {
            "type": "boolean",
            "description": "Whether the group is hidden",
            "example": false
          },
          "txHash": {
            "type": "string",
            "description": "Transaction hash for the group",
            "example": null
          },
          "resolutionTxHash": {
            "type": "string",
            "description": "Resolution transaction hash",
            "example": null
          },
          "priorityIndex": {
            "type": "number",
            "description": "Priority index of the group",
            "example": 0
          },
          "metadata": {
            "type": "object",
            "description": "Group metadata",
            "example": {
              "isBannered": false
            }
          },
          "negRiskMarketId": {
            "type": "string",
            "description": "Onchain NegRisk market ID as identified by the NegriskAdapter smart-contract",
            "example": "0xe103633b40e9b664f8acc89e8cf7b7916475961ae1708a249fa5d6c933168c00"
          },
          "createdAt": {
            "type": "string",
            "description": "Creation timestamp",
            "example": "2025-04-07T17:20:22.135Z"
          },
          "updatedAt": {
            "type": "string",
            "description": "Last update timestamp",
            "example": "2025-04-07T17:22:08.464Z"
          }
        },
        "required": [
          "id",
          "slug",
          "title",
          "status",
          "deadline",
          "hidden",
          "priorityIndex",
          "metadata",
          "negRiskMarketId",
          "createdAt",
          "updatedAt"
        ]
      },
      "HistoryMarketDto": {
        "type": "object",
        "properties": {
          "closed": {
            "type": "boolean",
            "description": "Whether the market is closed",
            "example": false
          },
          "collateral": {
            "type": "object",
            "description": "Collateral token information",
            "example": {
              "symbol": "USDC",
              "id": 7,
              "decimals": 6
            }
          },
          "group": {
            "description": "Market group information",
            "allOf": [
              {
                "$ref": "#/components/schemas/HistoryMarketGroupDto"
              }
            ]
          },
          "condition_id": {
            "type": "string",
            "description": "Condition ID of the market",
            "example": "0x08518bc4bb8a3dbb89aac4425ace0876b94a5dfa77dee47a20737a19cf67e325"
          },
          "funding": {
            "type": "number",
            "description": "Market funding amount",
            "example": 0
          },
          "id": {
            "type": "number",
            "description": "Market ID",
            "example": 980
          },
          "slug": {
            "type": "string",
            "description": "Market slug",
            "example": "market-1-1744046422691"
          },
          "title": {
            "type": "string",
            "description": "Market title",
            "example": "Market 1"
          },
          "deadline": {
            "type": "string",
            "description": "Market deadline",
            "example": "2025-04-11T22:34:56.000Z"
          }
        },
        "required": [
          "closed",
          "collateral",
          "group",
          "condition_id",
          "funding",
          "id",
          "slug",
          "title",
          "deadline"
        ]
      },
      "HistoryEntryDto": {
        "type": "object",
        "properties": {
          "blockTimestamp": {
            "type": "number",
            "description": "Block timestamp of the operation",
            "example": 1744115608
          },
          "collateralAmount": {
            "type": "string",
            "description": "Collateral amount involved in the operation",
            "example": "0"
          },
          "market": {
            "description": "Market information",
            "allOf": [
              {
                "$ref": "#/components/schemas/HistoryMarketDto"
              }
            ]
          },
          "outcomeTokenAmount": {
            "type": "string",
            "description": "Amount of outcome tokens involved",
            "example": "100"
          },
          "outcomeTokenAmounts": {
            "description": "Amounts of outcome tokens for each outcome",
            "example": [
              "100",
              "0"
            ],
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "outcomeIndex": {
            "type": "number",
            "description": "Index of the outcome",
            "example": 0
          },
          "outcomeTokenPrice": {
            "type": "number",
            "description": "Price of the outcome token",
            "example": 0.5
          },
          "strategy": {
            "type": "string",
            "description": "Type of operation",
            "example": "Convert",
            "enum": [
              "Buy",
              "Sell",
              "Limit Buy",
              "Limit Sell",
              "Market Buy",
              "Market Sell",
              "Split",
              "Merge",
              "Convert"
            ]
          },
          "transactionHash": {
            "type": "string",
            "description": "Transaction hash of the operation",
            "example": "0x992f36465f938b21a6a5fe3c417c98c3268a616a05479d2dc53870c6cd1a0761"
          }
        },
        "required": [
          "blockTimestamp",
          "collateralAmount",
          "market",
          "outcomeTokenAmount",
          "outcomeTokenAmounts",
          "outcomeIndex",
          "outcomeTokenPrice",
          "strategy"
        ]
      },
      "HistoryResponseDto": {
        "type": "object",
        "properties": {
          "data": {
            "description": "List of history entries",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/HistoryEntryDto"
            }
          },
          "totalCount": {
            "type": "number",
            "description": "Total count of entries",
            "example": 8
          }
        },
        "required": [
          "data",
          "totalCount"
        ]
      },
      "Order": {
        "type": "object",
        "properties": {
          "salt": {
            "type": "number",
            "description": "Unique random value for signature uniqueness (prevents replay attacks)",
            "example": 1234567890
          },
          "maker": {
            "type": "string",
            "description": "Ethereum address of the maker (order creator)",
            "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
            "pattern": "^0x[a-fA-F0-9]{40}$"
          },
          "signer": {
            "type": "string",
            "description": "Address that signed the order",
            "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
          },
          "taker": {
            "type": "string",
            "description": "Specific taker address (optional for open orders)",
            "example": "0x0000000000000000000000000000000000000000"
          },
          "tokenId": {
            "type": "string",
            "description": "Token ID being traded (YES or NO position ID from conditional token)",
            "example": "19633204485790857949828516737993423758628930235371629943999544859324645414627"
          },
          "makerAmount": {
            "type": "number",
            "description": "Amount the maker is offering (in wei, 18 decimals)",
            "example": 1000000000000000000,
            "minimum": 0
          },
          "takerAmount": {
            "type": "number",
            "description": "Amount the maker wants in return (in wei, 18 decimals)",
            "example": 750000000000000000,
            "minimum": 0
          },
          "expiration": {
            "type": "string",
            "description": "Order expiration timestamp",
            "example": "2025-04-30T23:59:59Z"
          },
          "nonce": {
            "type": "number",
            "description": "Order nonce for cancellation tracking",
            "example": 42
          },
          "price": {
            "type": "number",
            "description": "Order price as decimal (0.01-0.99, required for GTC orders)",
            "example": 0.75,
            "minimum": 0.01,
            "maximum": 0.99
          },
          "feeRateBps": {
            "type": "number",
            "description": "Fee rate in basis points (1% = 100)",
            "example": 0
          },
          "side": {
            "type": "number",
            "description": "Order side: 0 = BUY, 1 = SELL",
            "enum": [
              0,
              1
            ],
            "example": 0
          },
          "signature": {
            "type": "string",
            "description": "EIP-712 signature of order details",
            "example": "0x123abc456def789ghi0123abc456def789ghi0123abc456def789ghi0123456789012345678901"
          },
          "signatureType": {
            "type": "number",
            "description": "Signature type (0-3)",
            "enum": [
              0,
              1,
              2,
              3
            ],
            "example": 2
          }
        },
        "required": [
          "salt",
          "maker",
          "signer",
          "tokenId",
          "makerAmount",
          "takerAmount",
          "feeRateBps",
          "side",
          "signature",
          "signatureType"
        ]
      },
      "CreateOrderDto": {
        "type": "object",
        "properties": {
          "order": {
            "description": "Order details including signature and amounts",
            "allOf": [
              {
                "$ref": "#/components/schemas/Order"
              }
            ]
          },
          "ownerId": {
            "type": "number",
            "description": "Profile ID of the order owner",
            "example": 12345
          },
          "orderType": {
            "type": "string",
            "description": "Order type (GTC=Good Till Cancelled, FOK=Fill Or Kill)",
            "enum": [
              "FOK",
              "GTC"
            ],
            "example": "GTC"
          },
          "marketSlug": {
            "type": "string",
            "description": "Market identifier slug",
            "example": "biden-vs-trump-2024"
          }
        },
        "required": [
          "order",
          "ownerId",
          "orderType",
          "marketSlug"
        ]
      },
      "MakerMatch": {
        "type": "object",
        "properties": {}
      },
      "OrderResponseDto": {
        "type": "object",
        "properties": {
          "order": {
            "description": "Order details",
            "allOf": [
              {
                "$ref": "#/components/schemas/Order"
              }
            ]
          },
          "makerMatches": {
            "description": "Maker matches if order was matched immediately",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MakerMatch"
            }
          }
        },
        "required": [
          "order"
        ]
      },
      "ErrorResponseDto": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "Error message",
            "example": "Invalid order data"
          }
        },
        "required": [
          "message"
        ]
      },
      "CancelOrderResponseDto": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "Confirmation message for the cancelled order",
            "example": "Order canceled successfully"
          }
        },
        "required": [
          "message"
        ]
      },
      "DeleteOrderBatchDto": {
        "type": "object",
        "properties": {
          "orderIds": {
            "description": "Array of order IDs to be cancelled in a single batch operation",
            "example": [
              "6f52b6d2-6c9e-4a5c-8a4f-28ab4b7ff203",
              "9e31c452-8a2b-42d1-b327-65f18d07dc96"
            ],
            "items": {
              "type": "array"
            },
            "type": "array"
          }
        },
        "required": [
          "orderIds"
        ]
      },
      "CancelOrderFailure": {
        "type": "object",
        "properties": {
          "orderId": {
            "type": "string",
            "description": "Order ID that failed to cancel",
            "example": "b53f0e4b-1529-45cc-ad39-e27f4c6eab5a"
          },
          "reason": {
            "type": "string",
            "description": "Error code indicating the reason for failure",
            "example": "ORDER_NOT_FOUND",
            "enum": [
              "ORDER_NOT_FOUND",
              "UNKNOWN_ERROR"
            ]
          },
          "message": {
            "type": "string",
            "description": "User-friendly error message",
            "example": "Order not found or already canceled"
          }
        },
        "required": [
          "orderId",
          "reason",
          "message"
        ]
      },
      "CancelOrderBatchResponseDto": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "Confirmation message for the cancelled orders",
            "example": "Orders canceled successfully"
          },
          "canceled": {
            "description": "Array of successfully cancelled order IDs",
            "example": [
              "611badac-8dfc-48a0-b09e-59654adea1c5"
            ],
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "failed": {
            "description": "Array of orders that failed to cancel with reasons",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CancelOrderFailure"
            }
          }
        },
        "required": [
          "message"
        ]
      },
      "CancelAllOrdersResponseDto": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "Confirmation message for cancelling all orders",
            "example": "Orders canceled successfully"
          },
          "canceled": {
            "description": "Array of successfully cancelled order IDs",
            "example": [
              "611badac-8dfc-48a0-b09e-59654adea1c5"
            ],
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "failed": {
            "description": "Array of orders that failed to cancel with reasons",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CancelOrderFailure"
            }
          }
        },
        "required": [
          "message"
        ]
      }
    }
  }
}